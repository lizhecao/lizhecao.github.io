<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李哲操的博客</title>
  
  <subtitle>人的劣性很难去改变，但可贵的是我们仍然在不断地挑战它</subtitle>
  <link href="https://lizhecao.github.io/atom.xml" rel="self"/>
  
  <link href="https://lizhecao.github.io/"/>
  <updated>2024-03-06T08:23:43.220Z</updated>
  <id>https://lizhecao.github.io/</id>
  
  <author>
    <name>李哲操</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>trojan多网站共存(共用443端口)</title>
    <link href="https://lizhecao.github.io/2024/03/06/trojan%E5%A4%9A%E7%BD%91%E7%AB%99%E5%85%B1%E5%AD%98(%E5%85%B1%E7%94%A8443%E7%AB%AF%E5%8F%A3)/"/>
    <id>https://lizhecao.github.io/2024/03/06/trojan%E5%A4%9A%E7%BD%91%E7%AB%99%E5%85%B1%E5%AD%98(%E5%85%B1%E7%94%A8443%E7%AB%AF%E5%8F%A3)/</id>
    <published>2024-03-06T08:24:14.000Z</published>
    <updated>2024-03-06T08:23:43.220Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为自建vaultwarden密码管理器, 遇到了一个棘手的问题。 由于trojan需要运行在443端口（因为要伪装成正常流量），所以导致和vaultwarden或者其他网站产生了端口冲突。网上搜索下来，发现文章都讲得不是很细，踩了很多坑，所以这里详细记录下步骤。</p><blockquote><p>参考: <a href="https://www.chengxiaobai.com/trouble-maker/trojan-shared-443-port-scheme.html">Trojan 共用 443 端口方案 | 程小白</a></p></blockquote><p>具体原来上面这个引用文章已经介绍的很清晰了，我这里不再赘述，只讲最关键的配置。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理就是通过nginx的stream模块进行四层转发（因为trojan的原因不能在第七层，具体参考引用文章），trojan直接转发即可，自己的服务需要经过nginx本身加上ssl支持，所以需要多转一次</p><h1 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>trojan 部署在64411端口，trojan的自定义部署可以参考<a href="https://github.com/jinwyp/one_click_script/blob/master/README2_CN.md">one_click_script/README2_CN.md at master · jinwyp/one_click_script · GitHub</a><br>vaultwarden部署在1888端口<br>都需要实现通过nginx 443端口反向代理</p><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>nginx配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    map $ssl_preread_server_name $backend_name &#123;</span><br><span class="line">        bitwarden.lizhecao.cn warden;</span><br><span class="line">        gpt.lizhecao.cn trojan;</span><br><span class="line">        # 默认其他流量转发给trojan，这里没有限制，有其他服务更加适合的都可以配置</span><br><span class="line">        default trojan;</span><br><span class="line">    &#125;</span><br><span class="line"># 转发给nginx自己监听的端口，因为这里需要nginx来实现ssl访问vaultwarden</span><br><span class="line">    upstream warden &#123;</span><br><span class="line">        server 127.0.0.1:998;</span><br><span class="line">    &#125;</span><br><span class="line"># 直接转发给trojan的端口即可</span><br><span class="line">    upstream trojan &#123;</span><br><span class="line">        server 127.0.0.1:64411;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 reuseport;</span><br><span class="line">        listen [::]:443 reuseport;</span><br><span class="line">        proxy_pass  $backend_name;</span><br><span class="line">        ssl_preread on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"># ...默认配置忽略</span><br><span class="line"></span><br><span class="line"># 这里用来转发请求给vaultwarden</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 998 ssl;    # vaultwarden通过998端口转发</span><br><span class="line">        server_name _;    #对应的域名或者ip，把xxx.com改成你们自己的域名就可以了</span><br><span class="line">        ssl_certificate /nginxweb/cert/fullchain.cer;          #申请的xxx.crt文件的位置</span><br><span class="line">        ssl_certificate_key /nginxweb/cert/private.key;        #申请的xxx.key文件的位置</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:1888; # 最终转发给vaultwarden服务监听的端口</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Permission-denied-while-reading-upstream"><a href="#Permission-denied-while-reading-upstream" class="headerlink" title="Permission denied while reading upstream"></a>Permission denied while reading upstream</h3><p>查看nginx的error日志发现vaultwarden的请求一直报这个错误，原来是对应的文件没有权限导致的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R nginx:nginx /var/lib/nginx/tmp/proxy/*</span><br></pre></td></tr></table></figure><p>参考：<a href="https://serverfault.com/questions/235154/permission-denied-while-reading-upstream">nginx - Permission denied while reading upstream - Server Fault</a></p><h3 id="unknown-directive-“stream”-in-etc-nginx-nginx-conf-86"><a href="#unknown-directive-“stream”-in-etc-nginx-nginx-conf-86" class="headerlink" title="unknown directive “stream” in /etc/nginx/nginx.conf:86"></a>unknown directive “stream” in /etc/nginx/nginx.conf:86</h3><p>stream 模块不存在，直接安装即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx-mod-stream</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里要注意你的nginx也需要是通过yum install 的方式才可以，否则通过yum方式并不会安装到你自定义的nginx上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近因为自建vaultwarden密码管理器, 遇到了一个棘手的问题。 由于trojan需要运行在443端口（因为要伪装成正常流量），所以导致和vaultwarden或者其他网站产生了端口冲突。网上搜索下来，发现文章都讲得不是很细，踩了很多坑，所以这里详细记录下步骤。&lt;/p</summary>
      
    
    
    
    <category term="software" scheme="https://lizhecao.github.io/categories/software/"/>
    
    
    <category term="trojan" scheme="https://lizhecao.github.io/tags/trojan/"/>
    
    <category term="nginx" scheme="https://lizhecao.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>鼠标在显示器之间快速移动</title>
    <link href="https://lizhecao.github.io/2023/08/29/%E9%BC%A0%E6%A0%87%E5%9C%A8%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B9%8B%E9%97%B4%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/"/>
    <id>https://lizhecao.github.io/2023/08/29/%E9%BC%A0%E6%A0%87%E5%9C%A8%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B9%8B%E9%97%B4%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/</id>
    <published>2023-08-29T07:04:20.000Z</published>
    <updated>2024-08-21T10:17:54.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>mac多显示器的情况下，由于习惯用spotlight(alfred) 之类的软件切换应用，导致经常出现的情况下，我跳转（激活）到了另一个显示器上的一个应用，但是鼠标还停留在原显示器上，我想点一下，还得再移动下鼠标过来。多屏幕操作的时候的鼠标移动又挺浪费时间的。</p><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>在网上搜索后发现了一个很好用的方法，参考：<a href="https://apple.stackexchange.com/questions/268697/how-to-quickly-move-mouse-cursor-between-monitors#">How to quickly move mouse cursor between monitors</a> 下面ipatch的回答。</p><p>方法如下</p><ol><li>下载 <a href="http://www.hammerspoon.org/">hammerspoon</a></li><li>下载它的插件 spoon <a href="https://www.hammerspoon.org/Spoons/MouseFollowsFocus.html">MouseFollowsFocus</a>（如果觉得不适应的可以下载我的脚本，做了一些优化<a href="https://github.com/lizhecao/databases/blob/a418e216e29b411b6f997cf727b6d0cf9fc9f9f0/mac/hammerspoon/MouseFollowsFocus.spoon.zip">MyMouseFollowsFocus</a> ）</li><li>vim ~/.hammerspoon/init.lua</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mouse_follows_focus = hs.loadSpoon(<span class="string">&quot;MouseFollowsFocus&quot;</span>)</span><br><span class="line">mouse_follows_focus:configure(&#123;&#125;)</span><br><span class="line">mouse_follows_focus:start()</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote><p>默认的脚本存在一些对我使用体验较差的问题，所以我做了一些优化</p></blockquote><p>不想看原理的可以直接下载我的脚本即可：<a href="https://github.com/lizhecao/databases/blob/a418e216e29b411b6f997cf727b6d0cf9fc9f9f0/mac/hammerspoon/MouseFollowsFocus.spoon.zip">MyMouseFollowsFocus</a><br>如果需要定制化，可以在修改脚本后，重新加载就可以了。脚本默认加载后的位置在~/.hammerspoon/Spoons/MouseFollowsFocus.spoon/init.lua</p><ol><li>xnip截图软件会自动激活所有桌面，导致鼠标重复跳转。</li></ol><p>解决方法：直接禁用掉xnip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if hs.application.frontmostApplication():name() ~= &quot;Xnip Helper&quot; then</span><br><span class="line">  self:updateMouse(window)</span><br><span class="line">else</span><br><span class="line">  print(&quot;xnip app running&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="2"><li><p>同个显示器下鼠标也自动跳转了。这个很困扰我，因为同个显示器下移动有点错愕感，而且也没什么必要。因为距离很小了</p><p>解决方法：不同显示器下才跳转。判断的位置由应用变成显示器。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;why&quot;&gt;&lt;a href=&quot;#why&quot; class=&quot;headerlink&quot; title=&quot;why&quot;&gt;&lt;/a&gt;why&lt;/h1&gt;&lt;p&gt;mac多显示器的情况下，由于习惯用spotlight(alfred) 之类的软件切换应用，导致经常出现的情况下，我跳转（激活）到了另</summary>
      
    
    
    
    <category term="软件折腾" scheme="https://lizhecao.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="hammerspoon" scheme="https://lizhecao.github.io/tags/hammerspoon/"/>
    
  </entry>
  
  <entry>
    <title>protobuf转java bean的坑</title>
    <link href="https://lizhecao.github.io/2023/04/27/protobuf%E8%BD%ACjava%20bean%E7%9A%84%E5%9D%91/"/>
    <id>https://lizhecao.github.io/2023/04/27/protobuf%E8%BD%ACjava%20bean%E7%9A%84%E5%9D%91/</id>
    <published>2023-04-27T06:58:23.000Z</published>
    <updated>2024-03-06T07:28:29.658Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://juejin.cn/post/6982167131374747684">https://juejin.cn/post/6982167131374747684</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://juejin.cn/post/6982167131374747684&quot;&gt;https://juejin.cn/post/6982167131374747684&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="java" scheme="https://lizhecao.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://lizhecao.github.io/tags/java/"/>
    
    <category term="protobuf" scheme="https://lizhecao.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>软件电脑问题咨询解决服务</title>
    <link href="https://lizhecao.github.io/2022/09/16/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/"/>
    <id>https://lizhecao.github.io/2022/09/16/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-09-16T03:21:23.000Z</published>
    <updated>2024-03-06T07:28:29.659Z</updated>
    
    <content type="html"><![CDATA[<p>本人是一名软件开发工程师，目前就职于某大厂， 日常开发中遇到的软件问题也很多，所以积累了很多经验，希望能够帮到有需要的朋友。</p><p>服务内容包括但不限于以下几种：</p><ol><li>软件开发，数据处理工具（例如批量处理excel、文档）</li><li>软件安装、激活</li><li>其他各种软件问题（软件报错、无法运行之类）</li></ol><p><img src="/images/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/image-20220916113948499.png" alt="image-20220916113948499"></p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/image-20220916114326451.png" alt="image-20220916114326451"></p><p>有需要的可以通过以下几种方式联系我</p><ol><li><p>发邮件：<a href="mailto:&#x35;&#x34;&#x31;&#x39;&#x39;&#x35;&#x31;&#x34;&#x39;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x35;&#x34;&#x31;&#x39;&#x39;&#x35;&#x31;&#x34;&#x39;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></p></li><li><p>微信号：zhecaoli</p></li><li><p>直接在下面评论留言：给下你的邮箱或者微信号</p></li></ol><p>根据问题解决所需的时间，会适当收一点费用。介意勿联。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本人是一名软件开发工程师，目前就职于某大厂， 日常开发中遇到的软件问题也很多，所以积累了很多经验，希望能够帮到有需要的朋友。&lt;/p&gt;
&lt;p&gt;服务内容包括但不限于以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;软件开发，数据处理工具（例如批量处理excel、文档）&lt;/li&gt;
&lt;li&gt;软</summary>
      
    
    
    
    <category term="软件折腾" scheme="https://lizhecao.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>iterm2 rzsz zmodem 脚本上传下载失效(通过expect脚本登录)</title>
    <link href="https://lizhecao.github.io/2022/01/25/iterm2-rzsz-zmodem-%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%A4%B1%E6%95%88-%E9%80%9A%E8%BF%87expect%E8%84%9A%E6%9C%AC%E7%99%BB%E5%BD%95/"/>
    <id>https://lizhecao.github.io/2022/01/25/iterm2-rzsz-zmodem-%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%A4%B1%E6%95%88-%E9%80%9A%E8%BF%87expect%E8%84%9A%E6%9C%AC%E7%99%BB%E5%BD%95/</id>
    <published>2022-01-25T02:57:20.000Z</published>
    <updated>2024-03-06T07:28:29.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>iterm2本身不支持rzsz命令，所以需要通过本地安装脚本，设置触发器来实现这个功能，具体网上有很多教程。参考：<a href="https://github.com/aikuyun">aikuyun</a>/<strong><a href="https://github.com/aikuyun/iterm2-zmodem">iterm2-zmodem</a></strong></p><p>但是最近在公司的电脑发现按照网上的教程设置好了之后总是没作用。在用rz、sz命令的时候，虽然弹出了文件选择窗口，但是选择文件后就没有反应了。一开始总是以为是自己的设置出了什么问题，仔细检查了很多次都没作用。</p><h1 id="expect脚本的坑"><a href="#expect脚本的坑" class="headerlink" title="expect脚本的坑"></a>expect脚本的坑</h1><p>最后无意间在这个文章<a href="https://github.com/laggardkernel">laggardkernel</a>/**<a href="https://github.com/laggardkernel/iterm2-zmodem">iterm2-zmodem</a>**中发现了这么一句话</p><p><code>This tool may also fail if you are using </code>expect<code>or</code>rlogin<code> as it expects a mostly-clean 8-bit connection between the two parties.</code></p><p>开始怀疑起是不是我是通过expect脚本登录的原因。然后在网上查了下，果然有人遇到这种情况，于是按照教程<a href="https://blog.51cto.com/fulin0532/2439271"><strong>mac iterm2 expect 方式sz rz 失效</strong></a>设置了环境变量  LC_CTYPE=en_US后，居然就好了，神奇！！！</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li>在~/.bashrc 中添加一行 <code>export LC_CTYPE=en_US</code></li><li>保存后执行命令<code>source ~/.bashrc</code></li></ol><p>由于我使用的是fish，所以步骤有一点差异</p><ol><li>在 ~/.config/fish/config.fish 中添加一行 <code>set -x LC_CTYPE en_US</code></li><li>保存后执行命令 <code>source  ~/.config/fish/config.fish</code></li></ol><p>原理都是设置一个环境变量LC_CTYPE=en_US ，这样expect脚本运行时所在的shell就会使用到这个变量，然后就可以了。</p><p>或者也可以按照上述教程，新起一个脚本，在脚本中先export设置环境变量，然后再通过exec执行expect脚本。这样的好处就是不会影响到你的系统环境变量。缺点可能就是比较麻烦，有多个expect脚本可能要写多个额外的脚本。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote><p>上面的方式由于会修改到本地的语言，导致本地打开中文乱码的问题，所以还是被我pass了，优化后的方式如下</p></blockquote><ol><li><p>在iterm2的登录命令前面加上</p><p><code>export LC_CTYPE=en_US;</code></p><p><img src="/images/iterm2-rzsz-zmodem-%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%A4%B1%E6%95%88-%E9%80%9A%E8%BF%87expect%E8%84%9A%E6%9C%AC%E7%99%BB%E5%BD%95/image-20230713160934297.png" alt="image-20230713160934297"></p></li></ol><p>这样的方式只会影响到当前打开的这个会话，而且也不用专门写一个bash脚本了，非常6+1</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然网上已经有教程了，但是感觉都不是很清晰，费了好大劲才找到正确的方法，希望我这篇博文能够帮到也遇到这个问题的小伙伴。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;iterm2本身不支持rzsz命令，所以需要通过本地安装脚本，设置触发器来实现这个功能，具体网上有很多教程。参考：&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="软件折腾" scheme="https://lizhecao.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="iterm2" scheme="https://lizhecao.github.io/tags/iterm2/"/>
    
    <category term="expect" scheme="https://lizhecao.github.io/tags/expect/"/>
    
  </entry>
  
  <entry>
    <title>npm hexo-renderer-sass Mac安装报错</title>
    <link href="https://lizhecao.github.io/2021/10/13/npm%20hexo-renderer-sass%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"/>
    <id>https://lizhecao.github.io/2021/10/13/npm%20hexo-renderer-sass%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/</id>
    <published>2021-10-13T07:00:43.000Z</published>
    <updated>2024-03-06T07:28:29.658Z</updated>
    
    <content type="html"><![CDATA[<p>起因是要用hexo更换新的主题Maupassant，于是按照教程安装，<a href="https://www.haomwei.com/technology/maupassant-hexo.html%EF%BC%8C%E5%AE%89%E8%A3%85%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%8E%B0%60%60%60npm">https://www.haomwei.com/technology/maupassant-hexo.html，安装的时候发现```npm</a> install hexo-renderer-sass –save ``` 一直失败，报错如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node_modules/node-sass: Command failed.</span><br><span class="line">......</span><br><span class="line">1 error generated.</span><br><span class="line">make: *** [Release/obj.target/binding/src/binding.o] Error 1</span><br><span class="line">gyp ERR! build error </span><br><span class="line">gyp ERR! stack Error: `make` failed with exit code: 2</span><br><span class="line">gyp ERR! stack     at ChildProcess.onExit (/Users/andrzej/apps/stimulus_infinite_scroll/node_modules/node-gyp/lib/build.js:262:23)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (node:events:365:28)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12)</span><br><span class="line">gyp ERR! System Darwin 19.6.0</span><br><span class="line">gyp ERR! command &quot;/usr/local/Cellar/node/16.0.0/bin/node&quot; &quot;/Users/andrzej/apps/stimulus_infinite_scroll/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot; &quot;--verbose&quot; &quot;--libsass_ext=&quot; &quot;--libsass_cflags=&quot; &quot;--libsass_ldflags=&quot; &quot;--libsass_library=&quot;</span><br><span class="line">gyp ERR! cwd /Users/andrzej/apps/stimulus_infinite_scroll/node_modules/node-sass</span><br><span class="line">gyp ERR! node -v v16.0.0</span><br><span class="line">gyp ERR! node-gyp -v v3.8.0</span><br><span class="line">gyp ERR! not ok</span><br></pre></td></tr></table></figure><p>网上看的方法大部分都是说是网络的原因，可以通过下面两个方法解决</p><ol><li>更换淘宝镜像（<a href="https://github.com/tufu9441/maupassant-hexo/issues/225%EF%BC%89">https://github.com/tufu9441/maupassant-hexo/issues/225）</a></li><li>使用代理</li></ol><p>但是我都试了之后发现还是不行，一直报上面的错误。最后终于找到了一篇文章：<a href="https://dev.to/andrzejkrzywda/fixing-the-node-sass-problem-in-rails-node-downgrade-helps-16lh%EF%BC%8C%E9%87%8C%E9%9D%A2%E8%AF%B4%E6%98%AF**node%E7%89%88%E6%9C%AC**%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E6%94%B9%E6%88%90**node14**%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">https://dev.to/andrzejkrzywda/fixing-the-node-sass-problem-in-rails-node-downgrade-helps-16lh，里面说是**node版本**的原因，改成**node14**就可以了。</a></p><p>操作如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew remove node</span><br><span class="line">brew install node@14</span><br></pre></td></tr></table></figure><p>改完之后再重新npm install hexo-renderer-sass –save，发现还是有点问题，于是打开了<strong>终端的代理</strong>。再试了下，可以了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>node版本改成14</li><li>打开终端代理（使用vpn）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起因是要用hexo更换新的主题Maupassant，于是按照教程安装，&lt;a href=&quot;https://www.haomwei.com/technology/maupassant-hexo.html%EF%BC%8C%E5%AE%89%E8%A3%85%E7%9A%84%E</summary>
      
    
    
    
    <category term="软件折腾" scheme="https://lizhecao.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="hexo" scheme="https://lizhecao.github.io/tags/hexo/"/>
    
    <category term="blog" scheme="https://lizhecao.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>feign RequestInterceptor 拦截器统一修改post表单请求体</title>
    <link href="https://lizhecao.github.io/2020/12/26/feign-RequestInterceptor-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%BB%9F%E4%B8%80%E4%BF%AE%E6%94%B9post%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%E4%BD%93/"/>
    <id>https://lizhecao.github.io/2020/12/26/feign-RequestInterceptor-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%BB%9F%E4%B8%80%E4%BF%AE%E6%94%B9post%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%E4%BD%93/</id>
    <published>2020-12-26T08:05:43.000Z</published>
    <updated>2024-03-06T07:28:29.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RequestInterceptor介绍"><a href="#RequestInterceptor介绍" class="headerlink" title="RequestInterceptor介绍"></a>RequestInterceptor介绍</h1><p>现在很多开发都是用feign来请求三方接口。feign很方便，通过接口的方式来请求三方，有助于我们以面向接口编程，也简化了之前手工创建httpclient等麻烦的流程。但是对于三方接口中需要统一添加签名要怎么办呢？</p><p>莫慌，Feign给我们预留了一个RequestInterceptor接口，它可以在我们的请求发送之前对请求内容（包装成一个RequestTemplate）做统一的处理。那我们就可以在这里对请求参数做一些统一处理了</p><h1 id="拦截并修改post-json请求体"><a href="#拦截并修改post-json请求体" class="headerlink" title="拦截并修改post json请求体"></a>拦截并修改post json请求体</h1><p>我们有一个三方的接口是post json的，并且有统一的参数如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sign&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestampe&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">&#125;</span> <span class="comment">//真正的数据以json格式放在data中</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那我们声明的feign接口，使用的时候不可能每次都去构造这些通用的参数，应该只需要传变化的东西进来就好了。例如上面的{“a”: xxx}。那么不变的部分在哪里添加呢？答案就是我们的RequestInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过template获取到请求体（已经被转成json）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">    <span class="comment">// 构造通用的请求体</span></span><br><span class="line">    <span class="type">BaseReq</span> <span class="variable">baseReq</span> <span class="operator">=</span> translateToBaseReq(jsonBody);</span><br><span class="line">    <span class="comment">// 替换请求体</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">baseReqStr</span> <span class="operator">=</span> JSON.toJSONString(baseReq);</span><br><span class="line">    template.body(baseReqStr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们需要的Feign接口的注解中配置configuration，标明使用这个拦截器配置就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, url = &quot;hello&quot;, configuration = FeignInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloFeign</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> ConcreteData data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就ok了，是不是很简单，然后我们的接口参数中只需要写实际要传的具体数据的类就行了。</p><h1 id="拦截并修改post-form请求体"><a href="#拦截并修改post-form请求体" class="headerlink" title="拦截并修改post form请求体"></a>拦截并修改post form请求体</h1><p>post json搞定了，但接下来又出现了一个三方。它的接口是post表单形式的。有同学说，post表单我会。</p><p>网上也有很多这方面的教程，例如：<a href="https://www.jianshu.com/p/08a5dd04093e">2018-06-19 SpringCloud Feign Post表单请求</a>，但是关键是post表单了之后，怎么处理统一的请求体呢？很明显，像上面直接通过template.body方式替换是不行的，这样请求体就是json字符串了。而form格式是a=xxx&amp;b=xxx这样的。那有同学就说，我自己这样构造不就可以了？可以是可以，但是这就是在重复造轮子了。feign既然能发送post form的请求，说明它已经实现过了。那我们是不是可以借鉴下呢？</p><h2 id="一览源码"><a href="#一览源码" class="headerlink" title="一览源码"></a>一览源码</h2><p>那我们就顺着请求来看看feign是怎么post form的吧。（debug模式中在调用feign接口的地方step into）</p><p>首先来到了ReflectiveFeign类的 public Object invoke(Object proxy, Method method, Object[] args)方法。继续往下走在return dispatch.get(method).invoke(args);这里继续step into来到了SynchronousMethodHandler类的invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">//这里将参数构造成了最终的RequestTemplate，我们从这里进去看看</span></span><br><span class="line">    <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> RequestTemplate <span class="title function_">create</span><span class="params">(Object[] argv)</span> &#123;</span><br><span class="line">     <span class="comment">// 通过元数据初始化了一个RequestTemplate（不包含请求体）</span></span><br><span class="line">     <span class="type">RequestTemplate</span> <span class="variable">mutable</span> <span class="operator">=</span> RequestTemplate.from(metadata.template());</span><br><span class="line">     ......</span><br><span class="line"> <span class="comment">// 这里才是生成最后的template的地方，继续进去</span></span><br><span class="line">     <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> resolve(argv, mutable, varBuilder);</span><br><span class="line">     ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RequestTemplate <span class="title function_">resolve</span><span class="params">(Object[] argv,</span></span><br><span class="line"><span class="params">                                      RequestTemplate mutable,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, Object&gt; variables)</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">        <span class="comment">// 在这里对template的body进行了组装</span></span><br><span class="line">        encoder.encode(formVariables, Encoder.MAP_STRING_WILDCARD, mutable);</span><br><span class="line">     ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从这里encode方法就会调用SpringFormEncoder的encode方法，然后就会到FormEncoder的encode，最后调用到UrlencodedFormContentProcessor的process方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span> <span class="params">(RequestTemplate template, Charset charset, Map&lt;String, Object&gt; data)</span> <span class="keyword">throws</span> EncodeException &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">bodyData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 这里对请求体中的参数进行处理（Map&lt;String,?&gt;）</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Object&gt; entry : data.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry == <span class="literal">null</span> || entry.getKey() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 参数之间用&amp;连接</span></span><br><span class="line">      <span class="keyword">if</span> (bodyData.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bodyData.append(QUERY_DELIMITER);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 参数key value之间用=号连接</span></span><br><span class="line">      bodyData.append(createKeyValuePair(entry, charset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造application/x-www-form-urlencoded的请求头和charset</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">contentTypeValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()</span><br><span class="line">        .append(getSupportedContentType().getHeader())</span><br><span class="line">        .append(<span class="string">&quot;; charset=&quot;</span>).append(charset.name())</span><br><span class="line">        .toString();</span><br><span class="line"></span><br><span class="line">    <span class="type">val</span> <span class="variable">bytes</span> <span class="operator">=</span> bodyData.toString().getBytes(charset);</span><br><span class="line">    <span class="type">val</span> <span class="variable">body</span> <span class="operator">=</span> Request.Body.encoded(bytes, charset);</span><br><span class="line"><span class="comment">// 清空原来的header，然后设置新的header以及替换上面的body</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, Collections.&lt;String&gt;emptyList()); <span class="comment">// reset header</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, contentTypeValue);</span><br><span class="line">    template.body(body);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="分析改造"><a href="#分析改造" class="headerlink" title="分析改造"></a>分析改造</h2><p>从上面的源码中，我们可以看到其实feign就是通过SpringFormEncoder的encode方法，来将template的body替换成需要的表单数据的。那么这么encoder其实也是我们在post form的时候自己配置了@Bean注入的，那么我们同样也可以拿来用啊。</p><p>于是开始改造原来的Interceptor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignFormInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpringFormEncoder encoder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过template获取到请求体（已经被转成json）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">    <span class="comment">// 构造通用的请求体</span></span><br><span class="line">    <span class="type">BaseReq</span> <span class="variable">baseReq</span> <span class="operator">=</span> translateToBaseReq(jsonBody);</span><br><span class="line">    <span class="comment">// 通过encoder的encode方法，将我们的数据 改成表单数据，并替换掉原来的template中的body</span></span><br><span class="line">    encoder.encode(baseReq, Encoder.MAP_STRING_WILDCARD, template);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, url = &quot;hello&quot;, configuration = FeignFormInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloFeign</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(value = &quot;testForm&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testForm</span><span class="params">(<span class="meta">@RequestBody</span> ConcreteData data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来似乎ok了？nonono，还是出问题了。因为我们取出来的原来的body中的数据（通过template.requestBody().asString()）不是json字符串。因为我们的feign接口定义的是post表单的，所以请求参数就被改造成a=xxx&amp;b=xxx的形式了。所以这样就导致我们取出来的不是json串，那这样我们实际发送的data，也就是baseReq中的data的数据就是a=xxx&amp;b=xxx，但实际我们要求的是json形式的。</p><p>那这可咋办？看起来似乎只能够改造这个数据成json格式了。但这样未免稍嫌麻烦，而且也不知道中间有什么坑没有。我们不是想获得json串吗？那我接口还是定义成post json的不就可以了吗？机智</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, url = &quot;hello&quot;, configuration = FeignFormInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloFeign</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(value = &quot;testForm&quot;)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testForm</span><span class="params">(<span class="meta">@RequestBody</span> ConcreteData data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话，请求三方的header就又变成application/json的，并且数据也是json格式的。有人会说，不是encode里面会将header改造成application/x-www-form-urlencoded的吗？但那是在我们设置了consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE才会进入到最后的process方法。看下这个FormCoder的encode方法就知道了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span> <span class="params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="keyword">throws</span> EncodeException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentTypeValue</span> <span class="operator">=</span> getContentTypeValue(template.headers());</span><br><span class="line">    <span class="comment">// 这里获取了我们设置的header类型，也就是默认的application/json</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentType.of(contentTypeValue);</span><br><span class="line">    <span class="comment">// 没有处理这个contentType的processors，就直接返回了。</span></span><br><span class="line">    <span class="keyword">if</span> (!processors.containsKey(contentType)) &#123;</span><br><span class="line">      delegate.encode(object, bodyType, template);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">val</span> <span class="variable">charset</span> <span class="operator">=</span> getCharset(contentTypeValue);</span><br><span class="line">    <span class="comment">// 而我们之前设置consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE的时候就会到这里，然后调用到UrlencodedFormContentProcessor的process方法。那里才能改造header</span></span><br><span class="line">    processors.get(contentType).process(template, charset, data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>知道了原理后，那其实我们只要在进入这个encode方法之前，将我们的header改成application/x-www-form-urlencoded不就可以了吗？于是乎</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignFormInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpringFormEncoder encoder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过template获取到请求体（已经被转成json）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">    <span class="comment">// 构造通用的请求体</span></span><br><span class="line">    <span class="type">BaseReq</span> <span class="variable">baseReq</span> <span class="operator">=</span> translateToBaseReq(jsonBody);</span><br><span class="line">    <span class="comment">// 先改造下header成表单头，magic就出现了哈</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, Collections.&lt;String&gt;emptyList()); <span class="comment">// reset header</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, URLENCODED.getHeader());</span><br><span class="line">    <span class="comment">// 通过encoder的encode方法，将我们的数据 改成表单数据，并替换掉原来的template中的body</span></span><br><span class="line">    encoder.encode(baseReq, Encoder.MAP_STRING_WILDCARD, template);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，重要成功地拦截了feign的post表单请求，并统一加上了公用参数、签名等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>啪啪一通，总结下最后的解决方案吧。</p><ol><li>还是按照正常的post json的方式去写feign接口</li><li>在Interceptor中<ol><li>获取到json串并改造成最后的请求对象</li><li>修改header为application/x-www-form-urlencoded</li><li>通过springEncoder的encode方法构造最终的表单请求体，并替换掉template中的（SpringFormEncoder还是要我们自己注入到容器的，在feign的post表单教程中都会提到）</li></ol></li></ol><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="直接用aop？"><a href="#直接用aop？" class="headerlink" title="直接用aop？"></a>直接用aop？</h2><p>有的同学会说，整那么多事，直接搞个aop不就行。无论是post表单还是json，改造下请求参数就可以了。</p><p>确实这里直接用spring aop应该也能实现。有兴趣的同学可以试试。但是还是相对来说没那么直观，毕竟Interceptor是框架原生扩展，直接把参数都封装成RestTemplate给你了。如果用aop，可能要得去获取签名，签名做一些判断等</p><p>感谢以下的博主分享：</p><p><a href="https://www.javacodemonk.com/feign-requestinterceptor-in-spring-boot-cbe5d967">Feign RequestInterceptor in Spring Boot</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RequestInterceptor介绍&quot;&gt;&lt;a href=&quot;#RequestInterceptor介绍&quot; class=&quot;headerlink&quot; title=&quot;RequestInterceptor介绍&quot;&gt;&lt;/a&gt;RequestInterceptor介绍&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://lizhecao.github.io/categories/java/"/>
    
    
    <category term="源码学习" scheme="https://lizhecao.github.io/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="java" scheme="https://lizhecao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上Okhttp超时问题定位</title>
    <link href="https://lizhecao.github.io/2020/11/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOkhttp%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>https://lizhecao.github.io/2020/11/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOkhttp%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</id>
    <published>2020-11-26T11:24:14.000Z</published>
    <updated>2024-03-06T07:28:29.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>这几天突然发现线上调三方接口有些超时时间达到了16分钟，我们是通过feign okhttp的方式来调用的，而且设置了feign的okhttp超时时间的。而且我也看到有些请求确实是按照限制的10秒超时的。 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">10000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>看日志的过程中发现有一个这个16分钟的超时的错误虽然也是socketTimeout，但是它的timeout是在write的时候发生的。而其他正常的超时是在read的时候发生的。</p><p>16分钟超时的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.SocketTimeoutException: timeout at okio.SocketAsyncTimeout.newTimeoutException(Okio.kt:159) at okio.AsyncTimeout.exit$jvm(AsyncTimeout.kt:203) at okio.AsyncTimeout$sink$1.write(AsyncTimeout.kt:110)</span><br></pre></td></tr></table></figure><p>10秒超时的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.SocketTimeoutException: timeout at okio.SocketAsyncTimeout.newTimeoutException(Okio.kt:159) at okio.AsyncTimeout.exit$jvm(AsyncTimeout.kt:203) at okio.AsyncTimeout$source$1.read(AsyncTimeout.kt:163) </span><br></pre></td></tr></table></figure><p>然后接下来我了解了下readTimeout和 connectTimeout的概念，也知道了okhttp原来还有writeTimeout的说法。</p><p>参考：</p><p><a href="https://www.baeldung.com/okhttp-timeouts">A Quick Guide to Timeouts in OkHttp</a></p><p><a href="https://www.zhihu.com/question/21609463/answer/160100810">HTTP 在什么情况下会请求超时？ - 严振杰的回答 - 知乎</a></p><p>简单说下okhttp的这几个概念</p><ul><li>connectTimeout：这个比较简单，就是建立连接的超时时间</li><li>readTimeout：从建立连接开发，接收服务端的两个数据包之间的最大等待时间。<ul><li>例如说下载文件的时候，虽然下载很久但是也没有超时。就是因为服务端一直在给你喂数据，没停过。所以不会触发这个读超时</li></ul></li><li>writeTimeout：写超时是从客户端发送数据给服务端的时候，发送两个数据包之间最大的等待时间。</li><li>callTimeout：调用超时，顾名思义，就是整个调用过程的超时时间。包括了上面所有的时间，还有dns域名解析。</li></ul><p>根据上面的日志可以知道，16m的超时的时候我们还在write，发送请求。这就是为什么readTimeout没有生效的原因。因为都还没到read 服务端响应的时候。</p><p>于是我本地测试了下，在上传一个大文件的时候，即使上传的时间已经超过了readTimeout规定的时间，但还是没有触发readTimeout，等到上传完成的时候才触发。</p><p>那我是不是给他设置一个writeTimeout就可以了呢？但debug发现，原来okhttpClient默认就设置了writeTimeout为10秒。那为啥线上还是搞到了16m？注意下writeTimeout的定义，发送两个数据包之间最大的等待时间。那只要我一直在发，那就无法触发这个writeTimeout了。</p><p>于是我又测试了下，还是上传一个大文件，writeTimeout是默认的10秒。结果上传了3分钟还是没有触发write超时，还是一样write完了直接触发readTimeout。然后我将writeTimeout的时间设置到很小，例如10毫秒，结果就发现很快就触发了writeTimeout。跟线上的错误一样的异常日志。说明两个请求数据包之间间隔的时间超过了10毫秒。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>那问题就比较明朗了，就是线上其实一直都在写，只是对方带宽，网络环境等原因，导致发送请求很慢，但是一直在发。可能几秒发几个字节这样。所以没有触发writeTimeout，更不用说readTimeout。直到最后可能快结束了，出现了一些不可名状的原因，导致触发了writeTimeout。。。最后这个解释有点牵强，我也不清楚为什么最后的超时时间都是16分钟。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>通过设置okhttp的 callTimeout可以完美解决这个问题，简单粗暴。我不管你中间发生了什么，反正我一调用我就开始计时，超时了我就关闭io，然后给你返回个 InterruptIOException。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;这几天突然发现线上调三方接口有些超时时间达到了16分钟，我们是通过feign okhttp的方式来调用的，而且设置了feign的okhttp</summary>
      
    
    
    
    <category term="java" scheme="https://lizhecao.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://lizhecao.github.io/tags/java/"/>
    
    <category term="okhttp" scheme="https://lizhecao.github.io/tags/okhttp/"/>
    
  </entry>
  
  <entry>
    <title>开发心得</title>
    <link href="https://lizhecao.github.io/2020/11/25/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
    <id>https://lizhecao.github.io/2020/11/25/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</id>
    <published>2020-11-25T04:38:35.000Z</published>
    <updated>2024-03-06T07:28:29.659Z</updated>
    
    <content type="html"><![CDATA[<ul><li>开发要学会保护好自己。加班熬夜的时候可没有人陪着你。所以像这种要涉及到加班发布的方案一定要自己好好设计。可以不深夜搞一定要尽量不晚上搞。要深夜搞的一定要再三确认好各种细节。提前做好准备，确保深夜的时候需要的工作量很小很快。需要长时间的要确保程序自动化。</li><li>看源码之前一定要先好好了解这个框架/应用 的主要功能，怎么使用，有哪些扩展点。有个大概的了解之后再来看代码就舒服多了<ul><li>例如spring源码。我以前对spring只是停留在简单地用一下。大部分功能都不了解，那时候去看源码真的是一脸懵逼。在看了spring实战和spring揭秘后，特别是spring揭秘。我就了解了bean的生命周期，spring它在bean的创建过程中提供了很多扩展点。知道了beanFactory也有一些扩展点。知道了spring其实做的就是从xml读取配置，然后将配置解析成beanDefinition，然后再在getBean的时候从缓存或者直接用beanDefinition来创建bean。诸如此类的。那么，当我再来看源码的时候。诶，我就发现，源码好像在跟着我的想法走。我知道在createBean实例之后，为什么要调用aware的set方法了，为什么要调用beanPostProcessor的相关方法了等等。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;开发要学会保护好自己。加班熬夜的时候可没有人陪着你。所以像这种要涉及到加班发布的方案一定要自己好好设计。可以不深夜搞一定要尽量不晚上搞。要深夜搞的一定要再三确认好各种细节。提前做好准备，确保深夜的时候需要的工作量很小很快。需要长时间的要确保程序自动化。&lt;/li&gt;</summary>
      
    
    
    
    <category term="技术人生" scheme="https://lizhecao.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="思考" scheme="https://lizhecao.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>qq空间相册 批量下载 python脚本</title>
    <link href="https://lizhecao.github.io/2018/11/29/qq%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%86%8C-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-python%E8%84%9A%E6%9C%AC/"/>
    <id>https://lizhecao.github.io/2018/11/29/qq%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%86%8C-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-python%E8%84%9A%E6%9C%AC/</id>
    <published>2018-11-29T07:51:48.000Z</published>
    <updated>2024-03-06T07:28:29.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>心血来潮，想要整理一把老照片，都放到一处管理。有些老照片是放在qq空间上的，找了网上基本没什么软件，有的也是坑。索性自己写个python+selenium 脚本搞一搞<br>代码位置：<a href="https://github.com/lizhecao/qq-photo-download">https://github.com/lizhecao/qq-photo-download</a></p><h1 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h1><p>就省了吧，在conf.py配置文件中输入用户名密码，运行下脚本就可以了，还有要配置下图片存储路径</p><h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="/images/qq%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%86%8C-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-python%E8%84%9A%E6%9C%AC/qq%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E6%88%90%E6%9E%9C%E6%88%AA%E5%9B%BE.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;心血来潮，想要整理一把老照片，都放到一处管理。有些老照片是放在qq空间上的，找了网上基本没什么软件，有的也是坑。索性自己写个python+s</summary>
      
    
    
    
    <category term="工具开发" scheme="https://lizhecao.github.io/categories/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="https://lizhecao.github.io/tags/python/"/>
    
    <category term="自动化" scheme="https://lizhecao.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="工具" scheme="https://lizhecao.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iterm2 批量修改profiles</title>
    <link href="https://lizhecao.github.io/2018/11/27/zsh-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9profiles/"/>
    <id>https://lizhecao.github.io/2018/11/27/zsh-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9profiles/</id>
    <published>2018-11-27T06:58:23.000Z</published>
    <updated>2024-03-06T07:28:29.659Z</updated>
    
    <content type="html"><![CDATA[<p>iterm2 支持批量修改profiles，只不过这个功能比较难找到，备个案</p><p>先修改其中一个profile, 然后如下操作:<br>preferences -&gt; profiles -&gt; 选中已经修改的profile -&gt; (左下角) Other Actions -&gt; Bulk copy from Selected Profile -&gt; 勾选你要复制的配置(例如keys) -&gt; 下方选中要批量修改的profiles -&gt; 点击copy即可</p><p><img src="/images/zsh-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9profiles/1-5457843.png" alt="点击bulk copy后的页面"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;iterm2 支持批量修改profiles，只不过这个功能比较难找到，备个案&lt;/p&gt;
&lt;p&gt;先修改其中一个profile, 然后如下操作:&lt;br&gt;preferences -&amp;gt; profiles -&amp;gt; 选中已经修改的profile -&amp;gt; (左下角) Othe</summary>
      
    
    
    
    <category term="软件折腾" scheme="https://lizhecao.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="wiki" scheme="https://lizhecao.github.io/tags/wiki/"/>
    
    <category term="zsh" scheme="https://lizhecao.github.io/tags/zsh/"/>
    
  </entry>
  
</feed>
