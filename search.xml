<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>feign RequestInterceptor 拦截器统一修改post表单请求体</title>
    <url>/2020/12/26/feign-RequestInterceptor-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%BB%9F%E4%B8%80%E4%BF%AE%E6%94%B9post%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%E4%BD%93/</url>
    <content><![CDATA[<h1 id="RequestInterceptor介绍"><a href="#RequestInterceptor介绍" class="headerlink" title="RequestInterceptor介绍"></a>RequestInterceptor介绍</h1><p>现在很多开发都是用feign来请求三方接口。feign很方便，通过接口的方式来请求三方，有助于我们以面向接口编程，也简化了之前手工创建httpclient等麻烦的流程。但是对于三方接口中需要统一添加签名要怎么办呢？</p>
<p>莫慌，Feign给我们预留了一个RequestInterceptor接口，它可以在我们的请求发送之前对请求内容（包装成一个RequestTemplate）做统一的处理。那我们就可以在这里对请求参数做一些统一处理了</p>
<h1 id="拦截并修改post-json请求体"><a href="#拦截并修改post-json请求体" class="headerlink" title="拦截并修改post json请求体"></a>拦截并修改post json请求体</h1><p>我们有一个三方的接口是post json的，并且有统一的参数如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sign&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestampe&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">&#125;</span> <span class="comment">//真正的数据以json格式放在data中</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>那我们声明的feign接口，使用的时候不可能每次都去构造这些通用的参数，应该只需要传变化的东西进来就好了。例如上面的{“a”: xxx}。那么不变的部分在哪里添加呢？答案就是我们的RequestInterceptor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过template获取到请求体（已经被转成json）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">    <span class="comment">// 构造通用的请求体</span></span><br><span class="line">    <span class="type">BaseReq</span> <span class="variable">baseReq</span> <span class="operator">=</span> translateToBaseReq(jsonBody);</span><br><span class="line">    <span class="comment">// 替换请求体</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">baseReqStr</span> <span class="operator">=</span> JSON.toJSONString(baseReq);</span><br><span class="line">    template.body(baseReqStr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在我们需要的Feign接口的注解中配置configuration，标明使用这个拦截器配置就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, url = &quot;hello&quot;, configuration = FeignInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloFeign</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> ConcreteData data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就ok了，是不是很简单，然后我们的接口参数中只需要写实际要传的具体数据的类就行了。</p>
<h1 id="拦截并修改post-form请求体"><a href="#拦截并修改post-form请求体" class="headerlink" title="拦截并修改post form请求体"></a>拦截并修改post form请求体</h1><p>post json搞定了，但接下来又出现了一个三方。它的接口是post表单形式的。有同学说，post表单我会。</p>
<p>网上也有很多这方面的教程，例如：<a href="https://www.jianshu.com/p/08a5dd04093e">2018-06-19 SpringCloud Feign Post表单请求</a>，但是关键是post表单了之后，怎么处理统一的请求体呢？很明显，像上面直接通过template.body方式替换是不行的，这样请求体就是json字符串了。而form格式是a=xxx&amp;b=xxx这样的。那有同学就说，我自己这样构造不就可以了？可以是可以，但是这就是在重复造轮子了。feign既然能发送post form的请求，说明它已经实现过了。那我们是不是可以借鉴下呢？</p>
<h2 id="一览源码"><a href="#一览源码" class="headerlink" title="一览源码"></a>一览源码</h2><p>那我们就顺着请求来看看feign是怎么post form的吧。（debug模式中在调用feign接口的地方step into）</p>
<p>首先来到了ReflectiveFeign类的 public Object invoke(Object proxy, Method method, Object[] args)方法。继续往下走在return dispatch.get(method).invoke(args);这里继续step into来到了SynchronousMethodHandler类的invoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">//这里将参数构造成了最终的RequestTemplate，我们从这里进去看看</span></span><br><span class="line">    <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> RequestTemplate <span class="title function_">create</span><span class="params">(Object[] argv)</span> &#123;</span><br><span class="line">     <span class="comment">// 通过元数据初始化了一个RequestTemplate（不包含请求体）</span></span><br><span class="line">     <span class="type">RequestTemplate</span> <span class="variable">mutable</span> <span class="operator">=</span> RequestTemplate.from(metadata.template());</span><br><span class="line">     ......</span><br><span class="line"> 		<span class="comment">// 这里才是生成最后的template的地方，继续进去</span></span><br><span class="line">     <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> resolve(argv, mutable, varBuilder);</span><br><span class="line">     ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> RequestTemplate <span class="title function_">resolve</span><span class="params">(Object[] argv,</span></span><br><span class="line"><span class="params">                                      RequestTemplate mutable,</span></span><br><span class="line"><span class="params">                                      Map&lt;String, Object&gt; variables)</span> &#123;</span><br><span class="line">   			......</span><br><span class="line">        <span class="comment">// 在这里对template的body进行了组装</span></span><br><span class="line">        encoder.encode(formVariables, Encoder.MAP_STRING_WILDCARD, mutable);</span><br><span class="line">     		......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从这里encode方法就会调用SpringFormEncoder的encode方法，然后就会到FormEncoder的encode，最后调用到UrlencodedFormContentProcessor的process方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span> <span class="params">(RequestTemplate template, Charset charset, Map&lt;String, Object&gt; data)</span> <span class="keyword">throws</span> EncodeException &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">bodyData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 这里对请求体中的参数进行处理（Map&lt;String,?&gt;）</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Object&gt; entry : data.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry == <span class="literal">null</span> || entry.getKey() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 参数之间用&amp;连接</span></span><br><span class="line">      <span class="keyword">if</span> (bodyData.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bodyData.append(QUERY_DELIMITER);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 参数key value之间用=号连接</span></span><br><span class="line">      bodyData.append(createKeyValuePair(entry, charset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造application/x-www-form-urlencoded的请求头和charset</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">contentTypeValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()</span><br><span class="line">        .append(getSupportedContentType().getHeader())</span><br><span class="line">        .append(<span class="string">&quot;; charset=&quot;</span>).append(charset.name())</span><br><span class="line">        .toString();</span><br><span class="line"></span><br><span class="line">    <span class="type">val</span> <span class="variable">bytes</span> <span class="operator">=</span> bodyData.toString().getBytes(charset);</span><br><span class="line">    <span class="type">val</span> <span class="variable">body</span> <span class="operator">=</span> Request.Body.encoded(bytes, charset);</span><br><span class="line">		<span class="comment">// 清空原来的header，然后设置新的header以及替换上面的body</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, Collections.&lt;String&gt;emptyList()); <span class="comment">// reset header</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, contentTypeValue);</span><br><span class="line">    template.body(body);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析改造"><a href="#分析改造" class="headerlink" title="分析改造"></a>分析改造</h2><p>从上面的源码中，我们可以看到其实feign就是通过SpringFormEncoder的encode方法，来将template的body替换成需要的表单数据的。那么这么encoder其实也是我们在post form的时候自己配置了@Bean注入的，那么我们同样也可以拿来用啊。</p>
<p>于是开始改造原来的Interceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignFormInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpringFormEncoder encoder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过template获取到请求体（已经被转成json）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">    <span class="comment">// 构造通用的请求体</span></span><br><span class="line">    <span class="type">BaseReq</span> <span class="variable">baseReq</span> <span class="operator">=</span> translateToBaseReq(jsonBody);</span><br><span class="line">    <span class="comment">// 通过encoder的encode方法，将我们的数据 改成表单数据，并替换掉原来的template中的body</span></span><br><span class="line">    encoder.encode(baseReq, Encoder.MAP_STRING_WILDCARD, template);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, url = &quot;hello&quot;, configuration = FeignFormInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloFeign</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(value = &quot;testForm&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testForm</span><span class="params">(<span class="meta">@RequestBody</span> ConcreteData data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看起来似乎ok了？nonono，还是出问题了。因为我们取出来的原来的body中的数据（通过template.requestBody().asString()）不是json字符串。因为我们的feign接口定义的是post表单的，所以请求参数就被改造成a=xxx&amp;b=xxx的形式了。所以这样就导致我们取出来的不是json串，那这样我们实际发送的data，也就是baseReq中的data的数据就是a=xxx&amp;b=xxx，但实际我们要求的是json形式的。</p>
<p>那这可咋办？看起来似乎只能够改造这个数据成json格式了。但这样未免稍嫌麻烦，而且也不知道中间有什么坑没有。我们不是想获得json串吗？那我接口还是定义成post json的不就可以了吗？机智</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;hello&quot;, url = &quot;hello&quot;, configuration = FeignFormInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloFeign</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(value = &quot;testForm&quot;)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testForm</span><span class="params">(<span class="meta">@RequestBody</span> ConcreteData data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的话，请求三方的header就又变成application/json的，并且数据也是json格式的。有人会说，不是encode里面会将header改造成application/x-www-form-urlencoded的吗？但那是在我们设置了consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE才会进入到最后的process方法。看下这个FormCoder的encode方法就知道了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span> <span class="params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="keyword">throws</span> EncodeException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentTypeValue</span> <span class="operator">=</span> getContentTypeValue(template.headers());</span><br><span class="line">    <span class="comment">// 这里获取了我们设置的header类型，也就是默认的application/json</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentType.of(contentTypeValue);</span><br><span class="line">    <span class="comment">// 没有处理这个contentType的processors，就直接返回了。</span></span><br><span class="line">    <span class="keyword">if</span> (!processors.containsKey(contentType)) &#123;</span><br><span class="line">      delegate.encode(object, bodyType, template);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">val</span> <span class="variable">charset</span> <span class="operator">=</span> getCharset(contentTypeValue);</span><br><span class="line">    <span class="comment">// 而我们之前设置consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE的时候就会到这里，然后调用到UrlencodedFormContentProcessor的process方法。那里才能改造header</span></span><br><span class="line">    processors.get(contentType).process(template, charset, data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>知道了原理后，那其实我们只要在进入这个encode方法之前，将我们的header改成application/x-www-form-urlencoded不就可以了吗？于是乎</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignFormInterceptor</span> <span class="keyword">implements</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpringFormEncoder encoder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过template获取到请求体（已经被转成json）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonBody</span> <span class="operator">=</span> template.requestBody().asString();</span><br><span class="line">    <span class="comment">// 构造通用的请求体</span></span><br><span class="line">    <span class="type">BaseReq</span> <span class="variable">baseReq</span> <span class="operator">=</span> translateToBaseReq(jsonBody);</span><br><span class="line">    <span class="comment">// 先改造下header成表单头，magic就出现了哈</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, Collections.&lt;String&gt;emptyList()); <span class="comment">// reset header</span></span><br><span class="line">    template.header(CONTENT_TYPE_HEADER, URLENCODED.getHeader());</span><br><span class="line">    <span class="comment">// 通过encoder的encode方法，将我们的数据 改成表单数据，并替换掉原来的template中的body</span></span><br><span class="line">    encoder.encode(baseReq, Encoder.MAP_STRING_WILDCARD, template);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，重要成功地拦截了feign的post表单请求，并统一加上了公用参数、签名等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>啪啪一通，总结下最后的解决方案吧。</p>
<ol>
<li>还是按照正常的post json的方式去写feign接口</li>
<li>在Interceptor中<ol>
<li>获取到json串并改造成最后的请求对象</li>
<li>修改header为application/x-www-form-urlencoded</li>
<li>通过springEncoder的encode方法构造最终的表单请求体，并替换掉template中的（SpringFormEncoder还是要我们自己注入到容器的，在feign的post表单教程中都会提到）</li>
</ol>
</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="直接用aop？"><a href="#直接用aop？" class="headerlink" title="直接用aop？"></a>直接用aop？</h2><p>有的同学会说，整那么多事，直接搞个aop不就行。无论是post表单还是json，改造下请求参数就可以了。</p>
<p>确实这里直接用spring aop应该也能实现。有兴趣的同学可以试试。但是还是相对来说没那么直观，毕竟Interceptor是框架原生扩展，直接把参数都封装成RestTemplate给你了。如果用aop，可能要得去获取签名，签名做一些判断等</p>
<p>感谢以下的博主分享：</p>
<p><a href="https://www.javacodemonk.com/feign-requestinterceptor-in-spring-boot-cbe5d967">Feign RequestInterceptor in Spring Boot</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>源码学习</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2 rzsz zmodem 脚本上传下载失效(通过expect脚本登录)</title>
    <url>/2022/01/25/iterm2-rzsz-zmodem-%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%A4%B1%E6%95%88-%E9%80%9A%E8%BF%87expect%E8%84%9A%E6%9C%AC%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>iterm2本身不支持rzsz命令，所以需要通过本地安装脚本，设置触发器来实现这个功能，具体网上有很多教程。参考：<a href="https://github.com/aikuyun">aikuyun</a>/<strong><a href="https://github.com/aikuyun/iterm2-zmodem">iterm2-zmodem</a></strong></p>
<p>但是最近在公司的电脑发现按照网上的教程设置好了之后总是没作用。在用rz、sz命令的时候，虽然弹出了文件选择窗口，但是选择文件后就没有反应了。一开始总是以为是自己的设置出了什么问题，仔细检查了很多次都没作用。</p>
<h1 id="expect脚本的坑"><a href="#expect脚本的坑" class="headerlink" title="expect脚本的坑"></a>expect脚本的坑</h1><p>最后无意间在这个文章<a href="https://github.com/laggardkernel">laggardkernel</a>/**<a href="https://github.com/laggardkernel/iterm2-zmodem">iterm2-zmodem</a>**中发现了这么一句话</p>
<p><code>This tool may also fail if you are using </code>expect<code>or</code>rlogin<code> as it expects a mostly-clean 8-bit connection between the two parties.</code></p>
<p>开始怀疑起是不是我是通过expect脚本登录的原因。然后在网上查了下，果然有人遇到这种情况，于是按照教程<a href="https://blog.51cto.com/fulin0532/2439271"><strong>mac iterm2 expect 方式sz rz 失效</strong></a>设置了环境变量  LC_CTYPE=en_US后，居然就好了，神奇！！！</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>在~/.bashrc 中添加一行 <code>export LC_CTYPE=en_US</code></li>
<li>保存后执行命令<code>source ~/.bashrc</code></li>
</ol>
<p>由于我使用的是fish，所以步骤有一点差异</p>
<ol>
<li>在 ~/.config/fish/config.fish 中添加一行 <code>set -x LC_CTYPE en_US</code></li>
<li>保存后执行命令 <code>source  ~/.config/fish/config.fish</code></li>
</ol>
<p>原理都是设置一个环境变量LC_CTYPE=en_US ，这样expect脚本运行时所在的shell就会使用到这个变量，然后就可以了。</p>
<p>或者也可以按照上述教程，新起一个脚本，在脚本中先export设置环境变量，然后再通过exec执行expect脚本。这样的好处就是不会影响到你的系统环境变量。缺点可能就是比较麻烦，有多个expect脚本可能要写多个额外的脚本。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote>
<p>上面的方式由于会修改到本地的语言，导致本地打开中文乱码的问题，所以还是被我pass了，优化后的方式如下</p>
</blockquote>
<ol>
<li><p>在iterm2的登录命令前面加上</p>
<p><code>export LC_CTYPE=en_US;</code></p>
<p><img src="/images/iterm2-rzsz-zmodem-%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%A4%B1%E6%95%88-%E9%80%9A%E8%BF%87expect%E8%84%9A%E6%9C%AC%E7%99%BB%E5%BD%95/image-20230713160934297.png" alt="image-20230713160934297"></p>
</li>
</ol>
<p>这样的方式只会影响到当前打开的这个会话，而且也不用专门写一个bash脚本了，非常6+1</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然网上已经有教程了，但是感觉都不是很清晰，费了好大劲才找到正确的方法，希望我这篇博文能够帮到也遇到这个问题的小伙伴。</p>
]]></content>
      <categories>
        <category>软件折腾</category>
      </categories>
      <tags>
        <tag>iterm2</tag>
        <tag>expect</tag>
      </tags>
  </entry>
  <entry>
    <title>java wiki</title>
    <url>/2020/11/25/java-wiki/</url>
    <content><![CDATA[<p>记录java开发过程中遇到的坑坑洼洼或者很有意思的比较小的技术点</p>
<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><h2 id="优先级管理"><a href="#优先级管理" class="headerlink" title="优先级管理"></a>优先级管理</h2><ol>
<li><p>Maven 父pom中dependencyManagement版本优先级高于传递依赖版本，因此会覆盖传递依赖版本。参考链接：<a href="https://blog.csdn.net/jiaobuchong/article/details/81842503">Maven dependencyManagement中的依赖版本会覆盖传递依赖版本</a></p>
<p>特殊说明：由于idea中依赖关系图不能够展示版本号（奇怪）所以导致我一直不知道原来依赖的版本错了。所以最好用mvn dependency:tree -Dverbose -Dincludes=com.github.jsqlparser:jsqlparser 来定位问题</p>
</li>
</ol>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>wiki</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>npm hexo-renderer-sass Mac安装报错</title>
    <url>/2021/10/13/npm%20hexo-renderer-sass%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>起因是要用hexo更换新的主题Maupassant，于是按照教程安装，<a href="https://www.haomwei.com/technology/maupassant-hexo.html%EF%BC%8C%E5%AE%89%E8%A3%85%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%8E%B0%60%60%60npm">https://www.haomwei.com/technology/maupassant-hexo.html，安装的时候发现```npm</a> install hexo-renderer-sass –save ``` 一直失败，报错如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules/node-sass: Command failed.</span><br><span class="line">......</span><br><span class="line">1 error generated.</span><br><span class="line">make: *** [Release/obj.target/binding/src/binding.o] Error 1</span><br><span class="line">gyp ERR! build error </span><br><span class="line">gyp ERR! stack Error: `make` failed with exit code: 2</span><br><span class="line">gyp ERR! stack     at ChildProcess.onExit (/Users/andrzej/apps/stimulus_infinite_scroll/node_modules/node-gyp/lib/build.js:262:23)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (node:events:365:28)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12)</span><br><span class="line">gyp ERR! System Darwin 19.6.0</span><br><span class="line">gyp ERR! command &quot;/usr/local/Cellar/node/16.0.0/bin/node&quot; &quot;/Users/andrzej/apps/stimulus_infinite_scroll/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot; &quot;--verbose&quot; &quot;--libsass_ext=&quot; &quot;--libsass_cflags=&quot; &quot;--libsass_ldflags=&quot; &quot;--libsass_library=&quot;</span><br><span class="line">gyp ERR! cwd /Users/andrzej/apps/stimulus_infinite_scroll/node_modules/node-sass</span><br><span class="line">gyp ERR! node -v v16.0.0</span><br><span class="line">gyp ERR! node-gyp -v v3.8.0</span><br><span class="line">gyp ERR! not ok</span><br></pre></td></tr></table></figure>

<p>网上看的方法大部分都是说是网络的原因，可以通过下面两个方法解决</p>
<ol>
<li>更换淘宝镜像（<a href="https://github.com/tufu9441/maupassant-hexo/issues/225%EF%BC%89">https://github.com/tufu9441/maupassant-hexo/issues/225）</a></li>
<li>使用代理</li>
</ol>
<p>但是我都试了之后发现还是不行，一直报上面的错误。最后终于找到了一篇文章：<a href="https://dev.to/andrzejkrzywda/fixing-the-node-sass-problem-in-rails-node-downgrade-helps-16lh%EF%BC%8C%E9%87%8C%E9%9D%A2%E8%AF%B4%E6%98%AF**node%E7%89%88%E6%9C%AC**%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E6%94%B9%E6%88%90**node14**%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">https://dev.to/andrzejkrzywda/fixing-the-node-sass-problem-in-rails-node-downgrade-helps-16lh，里面说是**node版本**的原因，改成**node14**就可以了。</a></p>
<p>操作如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew remove node</span><br><span class="line">brew install node@14</span><br></pre></td></tr></table></figure>

<p>改完之后再重新npm install hexo-renderer-sass –save，发现还是有点问题，于是打开了<strong>终端的代理</strong>。再试了下，可以了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>node版本改成14</li>
<li>打开终端代理（使用vpn）</li>
</ol>
]]></content>
      <categories>
        <category>软件折腾</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf转java bean的坑</title>
    <url>/2023/04/27/protobuf%E8%BD%ACjava%20bean%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>参考：<a href="https://juejin.cn/post/6982167131374747684">https://juejin.cn/post/6982167131374747684</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>qq空间相册 批量下载 python脚本</title>
    <url>/2018/11/29/qq%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%86%8C-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>心血来潮，想要整理一把老照片，都放到一处管理。有些老照片是放在qq空间上的，找了网上基本没什么软件，有的也是坑。索性自己写个python+selenium 脚本搞一搞<br>代码位置：<a href="https://github.com/lizhecao/qq-photo-download">https://github.com/lizhecao/qq-photo-download</a></p>
<h1 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h1><p>就省了吧，在conf.py配置文件中输入用户名密码，运行下脚本就可以了，还有要配置下图片存储路径</p>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="/images/qq%E7%A9%BA%E9%97%B4%E7%9B%B8%E5%86%8C-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-python%E8%84%9A%E6%9C%AC/qq%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E6%88%90%E6%9E%9C%E6%88%AA%E5%9B%BE.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>trojan多网站共存(共用443端口)</title>
    <url>/2024/03/06/trojan%E5%A4%9A%E7%BD%91%E7%AB%99%E5%85%B1%E5%AD%98(%E5%85%B1%E7%94%A8443%E7%AB%AF%E5%8F%A3)/</url>
    <content><![CDATA[<p>最近因为自建vaultwarden密码管理器, 遇到了一个棘手的问题。 由于trojan需要运行在443端口（因为要伪装成正常流量），所以导致和vaultwarden或者其他网站产生了端口冲突。网上搜索下来，发现文章都讲得不是很细，踩了很多坑，所以这里详细记录下步骤。</p>
<blockquote>
<p>参考: <a href="https://www.chengxiaobai.com/trouble-maker/trojan-shared-443-port-scheme.html">Trojan 共用 443 端口方案 | 程小白</a></p>
</blockquote>
<p>具体原来上面这个引用文章已经介绍的很清晰了，我这里不再赘述，只讲最关键的配置。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理就是通过nginx的stream模块进行四层转发（因为trojan的原因不能在第七层，具体参考引用文章），trojan直接转发即可，自己的服务需要经过nginx本身加上ssl支持，所以需要多转一次</p>
<h1 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>trojan 部署在64411端口，trojan的自定义部署可以参考<a href="https://github.com/jinwyp/one_click_script/blob/master/README2_CN.md">one_click_script/README2_CN.md at master · jinwyp/one_click_script · GitHub</a><br>vaultwarden部署在1888端口<br>都需要实现通过nginx 443端口反向代理</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>nginx配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    map $ssl_preread_server_name $backend_name &#123;</span><br><span class="line">        bitwarden.lizhecao.cn warden;</span><br><span class="line">        gpt.lizhecao.cn trojan;</span><br><span class="line">        # 默认其他流量转发给trojan，这里没有限制，有其他服务更加适合的都可以配置</span><br><span class="line">        default trojan;</span><br><span class="line">    &#125;</span><br><span class="line">	# 转发给nginx自己监听的端口，因为这里需要nginx来实现ssl访问vaultwarden</span><br><span class="line">    upstream warden &#123;</span><br><span class="line">        server 127.0.0.1:998;</span><br><span class="line">    &#125;</span><br><span class="line">	# 直接转发给trojan的端口即可</span><br><span class="line">    upstream trojan &#123;</span><br><span class="line">        server 127.0.0.1:64411;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 reuseport;</span><br><span class="line">        listen [::]:443 reuseport;</span><br><span class="line">        proxy_pass  $backend_name;</span><br><span class="line">        ssl_preread on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">	# ...默认配置忽略</span><br><span class="line"></span><br><span class="line">	# 这里用来转发请求给vaultwarden</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 998 ssl;    # vaultwarden通过998端口转发</span><br><span class="line">        server_name _;    #对应的域名或者ip，把xxx.com改成你们自己的域名就可以了</span><br><span class="line">        ssl_certificate /nginxweb/cert/fullchain.cer;          #申请的xxx.crt文件的位置</span><br><span class="line">        ssl_certificate_key /nginxweb/cert/private.key;        #申请的xxx.key文件的位置</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:1888; # 最终转发给vaultwarden服务监听的端口</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Permission-denied-while-reading-upstream"><a href="#Permission-denied-while-reading-upstream" class="headerlink" title="Permission denied while reading upstream"></a>Permission denied while reading upstream</h3><p>查看nginx的error日志发现vaultwarden的请求一直报这个错误，原来是对应的文件没有权限导致的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R nginx:nginx /var/lib/nginx/tmp/proxy/*</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://serverfault.com/questions/235154/permission-denied-while-reading-upstream">nginx - Permission denied while reading upstream - Server Fault</a></p>
<h3 id="unknown-directive-“stream”-in-etc-nginx-nginx-conf-86"><a href="#unknown-directive-“stream”-in-etc-nginx-nginx-conf-86" class="headerlink" title="unknown directive “stream” in /etc/nginx/nginx.conf:86"></a>unknown directive “stream” in /etc/nginx/nginx.conf:86</h3><p>stream 模块不存在，直接安装即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install nginx-mod-stream</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里要注意你的nginx也需要是通过yum install 的方式才可以，否则通过yum方式并不会安装到你自定义的nginx上</p>
]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>trojan</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>写给刚上大学的弟弟的一封信</title>
    <url>/2018/11/29/%E5%86%99%E7%BB%99%E5%88%9A%E4%B8%8A%E5%A4%A7%E5%AD%A6%E7%9A%84%E5%BC%9F%E5%BC%9F%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</url>
    <content><![CDATA[<p>  亲爱的弟弟，转眼之间你已经要上大学了，恭喜你踏上了人生又一个新的里程碑，也希望你能够好好享受你接下来的四年的大学生活</p>
<p>  作为一个“过来人”，大哥想给你一些建议，这些建议大多是大哥由心而发，领悟到的时候总是感慨，哎如果我有哥哥或者要好的师兄，可以在我上大学的时候跟我这么说就好了，but 这就是人生（容我默默装下逼）哲文刚上大学的时候，那是我自己的状态不是很好，也没时间去告诉他一些我的心得，只是在后来偶尔聊天的时候提及一二，现在你上大学了，我觉得是时候好好整理下我想说的，关于大学生活的一点点建议。当然，也参考了一点网上的资料，毕竟有些东西可能感悟过，但是一下子也记不起来了</p>
<h1 id="社团"><a href="#社团" class="headerlink" title="社团"></a>社团</h1><p>  社团是大学必然会经历的一环，虽然大哥我当时去面一个挂一个，最后没加入什么社团，但是也算是有“经历”了。。社团建议你加入一两个即可，好处就是交几个朋友，多一点团体活动。有人说还会锻炼沟通能力，领导能力，我就不清楚了。认识几个师兄师姐，这样你会了解他们毕业之后都去哪里，在哪里找实习等，说不定还可以直接给你推荐工作。<br>  不过社团太多的话会占用过多时间，就得不偿失了，毕竟我们码农要学习的东西很多</p>
<h1 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h1><p>  刚上大学会认识很多的新同学，慢慢你会跟其中几个人很要好，可能是你的舍友，也可以是同班同学，也可能是社团的朋友。大哥希望你选择积极向上，人品学识好的同学做朋友。孟母三迁，是有道理的，好的朋友能够一起进步，互相促进。而不是一起堕落，一起打机，特别是对于刚刚离开家里，开始真正独立的你，社会纷繁杂乱</p>
<h1 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h1><p>  多去图书馆，看多几本书，每个人的人生都是独特的，但是你所能经历体会的也只有 “一个”。但是看书就不同了，在书中你可以看到 各种各样的人生，感受不同的世界不同的人生，历史的跌但起伏。这岂不是比你玩多几把游戏带给你更多的东西？看书的同时要多做笔记，思考消化，才能转化为自己内在的东西（这一点大哥也是没做到，有心无力😂）</p>
<h1 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h1><p>  大哥现在每天早上都会起床跑步或者健身游泳，这个习惯是在我毕业一年后才慢慢养成的，我想如果我在大学的时候也能养成这样的习惯，那该多好啊。多运动吧，除了篮球之外应该选择以一两个 可以自己一个人就能做的运动，就好像跑步，随时随地，撒开腿就可以跑，多好啊。运动除了强身健体，让你不会动不动就感冒咳嗽之外，每天早上运动完可以让你一天都神清气爽，充满活力🌞<br>  也不要熬夜，养成早睡早起的习惯，因为熬夜总是要还回来的</p>
<h1 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h1><p>  养成几个好的习惯，例如每天运动一小时，晚上刷牙，每天八杯水，读书一小时之类的。可以用《我的小目标》这个软件来记录你要养成的习惯，每晚check一下。我的想法就是多几个好习惯，你自然而然就会变得优秀了，没有远大的目标看起来那么虚无缥缈，实实在在的小习惯，可以让你慢慢脱颖而出</p>
<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><p>  学会管理自己要完成的任务，每一件事情都可以细化到一个个切实的动作。例如你要去超市买生活用品，那这件事情就可以分为写购物清单，到超市购物。推荐你看下《Getting thing done&gt;&gt;  这本书，介绍了一种很受欢迎的任务管理理念–GTD，可以让你更愉快轻松地管理你的事情。切实到完成一件具体的任务了，如果你感觉心情烦乱，顾虑很多，不能专注于当前的任务，推荐你用下 我之前跟你说过的《番茄土豆》，用番茄钟来 完成一个具体的任务。这也是大哥在工作后才学到的技巧，有时候会觉得如果能在大学就知道多好😂</p>
<h1 id="逃课与期末考"><a href="#逃课与期末考" class="headerlink" title="逃课与期末考"></a>逃课与期末考</h1><p>  逃课是必然的，例如马列思想，毛泽东思想啥的，如果确实不感兴趣的课，可以考虑不去上课，但是不上课的话也不要宅在宿舍。<br>  宿舍这一点也在这里说的，宿舍是堕落的温床，很多人穷其四年就是在大学的宿舍里面打了四年机，完全没有体验到真正的大学生活。所以尽量不要在宿舍多呆，中午休息和晚上回来休息就可以了<br>  期末考试不要害怕，最低的目标是不挂科。有些课你确实是平常不怎么看的，例如大学物理，化学啥的，大学不用像以前那样每天都去做习题，买练习册。平常你主要看专业相关的书，学习像学的技术。那考试了怎么办？都要考啊所有课程。很多人都是在考前两周一周，甚至过分的考前一天才真正在看课本，按照老师圈的重点来看，或者找师兄要往年的考题（认识师兄的原因😂）一般几天就可以完成了。一般来说出的题肯定是老师圈的重点，一本厚厚的书，圈下来其实要看的真的不多，有时候考题直接就是去年的考卷。只要不挂科就可以了，毕竟挂了科还要补考，那就不好了。不挂科 = 顺利毕业，当然，如果你有拿奖学金的心，那就要提前一点刷。我这样说，就是让你平常可以安心去做你想做的其他事，学想学的技术，而不会顾此失彼，忧心忡忡，大家都是这么过来的，学霸也如此。</p>
<h1 id="专业技术"><a href="#专业技术" class="headerlink" title="专业技术"></a>专业技术</h1><p>  技术方面我觉得倒是其次，你能够养成上面所说的好习惯，会管理时间和事情，交到好的朋友，有些东西就是顺其自然的了。（站着说话不腰疼）<br>  咳咳，首先，学会一门语言，例如java，C，python，object-C用这个语言做点有趣的东西来，例如用object-c 开发一个 ios版的贪吃蛇，用java写一个简单的聊天室，在边学的过程边想着怎么做，这样你学习起来就不会太茫然，知道自己 学到这个 “语法” 有什么作用，能用在这个程序里面什么地方，当你完成了这个程序之后，你就基本入门了。在这个过程中要多用百度谷歌，不会的东西就多搜索，一定要善用搜索引擎，这是我们的第一老师。实在找不到的，可以问下同学，师兄，老师（当然还有我）。多搜多问。<br>  还有也可以参加学校的acm，这是一个计算机的算法竞赛，但是不要畏惧它，在我看来，这个是一个你以后找工作的很好的敲门砖，而且你也不用担心自己拿不到好成绩。因为在这里你可以认识一帮厉害的大神同学，老师，和他们一起学习，你会进步 得更快<br>  也可以参加一些学校的编程活动，创新比赛，或者自己想一个有趣或实用的软件，网站，去实现它（这个不同于上面学语言的时候完成的小程序，是一个真正的软件，网站）在这个过程中，你会学习到完成一个项目所需要的种种知识。当你完成它，更幸运的是，有人提出了建议，你继续维护更新它，在这个过程中，你已经成为了一个软件开发工程师了，恭喜你。<br>  至于具体看什么书籍？我觉得没有必要建议，哪怕直接在网上看在线教程，都是可以的。还是那句话，搜</p>
<h1 id="多输出"><a href="#多输出" class="headerlink" title="多输出"></a>多输出</h1><p>  可以在简书，csdn，博客园这些网站上开自己的博客，也可以用印象笔记，有道笔记这类的软件，就像上面《读书》中提到的，多记笔记，多做一些总结。那学习也是一样，在你学习了一门新的语言，或者一种新的语法，记下你自己的理解，只有记下来才能理解的更深更久。关于写笔记，博客，推荐你看下 刘未鹏的《为什么你应该从现在开始写博客》<a href="https://kb.cnblogs.com/page/517038/">https://kb.cnblogs.com/page/517038/</a></p>
<h1 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h1><p>  早一点实习，大二的暑假，大三的暑假都可以找找软件开发的实习了，在公司里面学习，成长的速度是你在学校所远远不及的。你会了解到一个项目开发的真正企业级实践流程，这样的经历不管是对你之后的学习还是工作，都会有很好的帮助，所以可能的话，早点实习。</p>
<h1 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h1><p>  我也鼓励你哲文哥多出去走走，趁着大学有时间，趁着年轻，多出去看看大好河山。不用担心钱的问题，就算没钱也可以穷游，边工作边旅游。至于为什么？千人千面，你自己体会一两次，看自己喜好😄</p>
<h1 id="珍惜当下"><a href="#珍惜当下" class="headerlink" title="珍惜当下"></a>珍惜当下</h1><p>  这个也是大哥的一点心得，刚上大学的时候，或许你还在感慨自己当初多努力一点就可以到更好的学校，又或许。。。其实，眼下的就是最好的安排。你要珍惜你当前所遇到的同学，老师，你的学校，你的专业等等，尽情愉快地感受你的四年的大学生活吧，为什么不呢？说不定这就是你人生最后的四年在学校的生活，之后的你就要每天朝九晚五，上班下班了？那么，还有什么理由不好好珍惜享受呢😄</p>
]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>开发心得</title>
    <url>/2020/11/25/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ul>
<li>开发要学会保护好自己。加班熬夜的时候可没有人陪着你。所以像这种要涉及到加班发布的方案一定要自己好好设计。可以不深夜搞一定要尽量不晚上搞。要深夜搞的一定要再三确认好各种细节。提前做好准备，确保深夜的时候需要的工作量很小很快。需要长时间的要确保程序自动化。</li>
<li>看源码之前一定要先好好了解这个框架/应用 的主要功能，怎么使用，有哪些扩展点。有个大概的了解之后再来看代码就舒服多了<ul>
<li>例如spring源码。我以前对spring只是停留在简单地用一下。大部分功能都不了解，那时候去看源码真的是一脸懵逼。在看了spring实战和spring揭秘后，特别是spring揭秘。我就了解了bean的生命周期，spring它在bean的创建过程中提供了很多扩展点。知道了beanFactory也有一些扩展点。知道了spring其实做的就是从xml读取配置，然后将配置解析成beanDefinition，然后再在getBean的时候从缓存或者直接用beanDefinition来创建bean。诸如此类的。那么，当我再来看源码的时候。诶，我就发现，源码好像在跟着我的想法走。我知道在createBean实例之后，为什么要调用aware的set方法了，为什么要调用beanPostProcessor的相关方法了等等。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术人生</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>戊戍北马感悟</title>
    <url>/2018/11/29/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<blockquote>
<p>同样是十年，与其稀里糊涂地活过，目标明确、生气勃勃地活当然令人远为满意。在个人的局限性中，可以让自己有效地燃烧，哪怕一丁点儿，这便是跑步一事的本质，也是活着一事的隐喻 ——村上春树</p>
</blockquote>
<p>转眼间，从开始跑步到现在已经将近三年了。从整天都宅在宿舍的典型IT男，到现在居然跑了<strong>北京马拉松</strong>（国马），跑者心目中的<strong>朝圣</strong>之马，而且还跑了个自己还算满意的成绩，想来真是很有意思的经历，所以这里要记录一二。</p>
<h1 id="开始跑步"><a href="#开始跑步" class="headerlink" title="开始跑步"></a>开始跑步</h1><p>  大概从16年开始跑步，记得刚开始啥都不懂，晚上穿上鞋子就跑出去，一路冲到宝体，转一圈外面的大圈就往回跑，差不多2～3公里。一开始只知道拔开腿狂奔，跑到气喘呼呼就是完成任务。突然增加的跑量和速度，很快就给我上了跑者的第一课——<strong>伤痛</strong>。出现的症状是早上起床的时候很痛，走一会后就缓解了，下楼梯时也很痛，网上搜索之后发现这就是鼎鼎大名的<strong>跑者膝</strong>，也就是<strong>髂胫束疼痛综合症</strong>，多因跑者突然增加跑量或速度引起。当时休养了好一阵子，后来还去药店搞了几块“狗皮膏药” 贴着，好像有点效果，过段时间就好了。打那以后就再不敢瞎跑了，开始学会慢跑。<br> 后来突然有一天心血来潮改成早上去跑，到宝体的二楼，呼吸着早晨的新鲜空气，而且早上也有很多的跑友在这里跑步，气氛很好，慢慢地就改成了晨跑了。在二楼田径场上面经过的时候，总是会看到下面田径场也好多人在跑步，而且都穿着运动服，看起来都跑得很快，一开始还以为下面是专门田径队训练的呢。后来才发现原来是对外开放的，这么好的场地，那我干嘛不去跑呢。于是开始在宝体田径场晨跑，一直到现在，对这一方红色的土地也是有了一份情感。</p>
<h1 id="加入奔跑者"><a href="#加入奔跑者" class="headerlink" title="加入奔跑者"></a>加入奔跑者</h1><p>  一开始在宝体田径场，我也只能跑到5km，感觉就很累了，那时已经开始用咕咚记录跑步了，也买了一个放手机的臂包，可以看到当时的记录都是5km，不能更多了。<br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/16%E5%B9%B47%E6%9C%88%E8%B7%91%E6%AD%A5%E8%AE%B0%E5%BD%95-5455454.png" alt="image.png"><br>当时还没加入任何组织，也没觉得有什么必要加，自己跑自己的就挺好的。印象深刻的就是杨队，年纪很大但是跑起来跟飞一样，我跑个4km不到已经套我好几圈，而且每次好像我到了他就在跑了，我跑完了他还在跑。说话声音也中气十足，总是在讲跑马或者配速什么的，当时我也不懂这些，就那么一笑置之。还有就是这些穿着相同衣服的人跑完步会在一起拍照或者聊天吃东西，而我跑完之后就跑回去了，在家门口拉伸下冲凉上班，没有任何交集。直到有一天认识了江贤满–江哥，其实天天在田径场跑的就那些人，都是很熟悉的陌生人。那天我们正好一起跑了一段路，边跑边聊天，跑完之后江哥就拉我到奔跑者，后来才知道我是他第一个推荐进奔跑者的，后面还有小冉。加入奔跑者的时候，记得当时群上已经有360人，我刚好是第361，到现在奔跑者宝体分部的群早就满人好几次了。奔跑者的好我就不多说了，到现在它也是我心目中最好的跑团。（无拘无束，默默服务，气氛活跃….）</p>
<h1 id="例跑10km"><a href="#例跑10km" class="headerlink" title="例跑10km"></a>例跑10km</h1><p>  从加入奔跑者之后，看着群上的人每天都是打卡10k甚至半马全马的，而且天天跟着江哥跑，跑量也开始增加了。一开始从5k提到了8k，再过几个月又提到了10k，终于能打出在这个群中的<strong>常规卡</strong><br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/16%E5%B9%B410%E6%9C%88%E8%B7%91%E6%AD%A5%E8%AE%B0%E5%BD%95.png" alt="16年10月份加入奔跑者后的记录"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/17%E5%B9%B43%E6%9C%88%E8%B7%91%E6%AD%A5%E8%AE%B0%E5%BD%95.png" alt="17年3月份之后开始10km日常"></p>
<p>在加入奔跑者不久后，我又认识了跑步路上最重要的人——邓锦平<strong>邓哥</strong>，第一次跟他跑是在宝体二楼，可能当时田径场又是搞什么活动。一起跑的过程中，他开始给我讲跑步的学问</p>
<blockquote>
<p>跑前跑后要多拉伸，跑步的步伐不要太大，要高步频，低步幅等等</p>
</blockquote>
<p>真是受益匪浅，于是之后在宝体我就经常跟着他，还有江哥一起跑，周末一有时间就一起去铁仔山拉个半马，就在那时候，我的跑步耐力，技术各方面开始提高了</p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E4%BD%93%E9%82%93%E5%93%A5%E8%B4%A4%E5%93%A5%E6%9D%A8%E9%98%9F%E9%BD%90%E8%B7%91.jpg" alt="跟江哥，邓哥一起在宝体日常巡逻"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E4%BD%93%E4%BE%8B%E8%B7%91%E5%90%88%E7%85%A7.jpg" alt="跑完步之后也习惯并享受跟大家一起拍照打卡"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E9%93%81%E4%BB%94%E5%B1%B1%E4%BE%8B%E8%B7%91%E5%90%88%E7%85%A7.jpg" alt="跟邓哥，杨队还有奔跑者的大家一起到铁仔山拉练"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E9%93%81%E4%BB%94%E5%B1%B1%E9%82%93%E5%93%A5%E9%BD%90%E8%B7%91.jpg" alt="感谢雅风摄影师给我们留下了很多难忘的瞬间"></p>
<p>慢慢地，发现跑个10km也很轻松了，周末拉个半马也不觉得累，跟着邓哥拉伸下又活蹦乱跳了。跑步也不再是自己一个人孤独地跑，而是跟着跑友有说有笑，见面互相问下跑了多少啊，什么配速啊，跑完之后一群人开心地合影，一起在补给点聊天，听他们互相吹捧马拉松的成绩，心生向往，也开始有了跑马的想法。认识的跑友也渐渐多了起来，包括发哥，老杜，陈珍，猪宝等等，我想这也是多亏了跑步才能交到这么多朋友</p>
<h1 id="第一个马拉松——宝马"><a href="#第一个马拉松——宝马" class="headerlink" title="第一个马拉松——宝马"></a>第一个马拉松——宝马</h1><p>第一个马拉松是去年的<strong>宝安国际马拉松</strong>，当时也是初生牛犊不怕虎，就仗着平常跟着江哥他们跑五分也不累，而且他们总是跟我说你330没问题的，就想着跑个330。跑马前跑量也很一般，就120多点，只能说自己太年轻了，居然信了这帮老马的吹捧也不掂量下几斤几两<br>12月3号开跑，那天天气也是晒得很，我还傻傻地跟着330兔子飞奔，心里还自我感觉良好。半马的时候只用了1:44。结果可想而知，20多公里的时候就碰到了传说中的<strong>撞墙</strong>，双脚感觉要抽要抽的，整个人也感觉很累，于是开始降速，边跑边走边拉伸。。后面路过一个医疗点，索性直接躺下让志愿者帮忙拉伸，一拉就开始抽，真是不想起来了。不知道当时是怎么坚持下来的，好几次都想退赛算了，但想到自己的第一个马拉松就这样结束，想到那么多人都能跑完，最后还是拉伸一会跑一会，坚持慢摇到终点了。跑过终点的那一刻，那种喜悦真是无以言表，看着志愿者伸出手向我们祝贺，我也愉快地和他们击掌，完全忘了刚才一路的酸痛了。拿出奖牌，自豪地挂在脖子上的那一刻，心里美滋滋的。或许这就是马拉松的魅力，你切切实实地感受到，那种经过自己努力而成长，获得的喜悦。<br>宝马就这样以407的成绩结束了，记几个难忘的瞬间</p>
<ul>
<li>谢谢发哥中途的陪跑，后面他自己就单飞了，虽然嘴上一直跟我说跑不动了，追不上我</li>
<li>侯哥在起跑前教我怎么绑肯定都不会掉的鞋带</li>
<li>邓哥那天作为工作人员没跑，但是专门跑到30km左右处给我们拍照，为我们加油打气</li>
<li>在医疗点耐心为我拉伸的志愿者<br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E4%BD%93%E6%94%BF%E5%BA%9C%E5%B9%BF%E5%9C%BA%E4%BE%8B%E8%B7%91%E5%90%88%E7%85%A7.jpg" alt="起跑前奔跑者的队友们在一起愉快地合影"></li>
</ul>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E9%A9%AC%E5%A5%96%E7%89%8C.jpg" alt="第一个全马奖牌--宝马"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E9%A9%AC%E8%B7%91%E6%AD%A5%E8%AE%B0%E5%BD%95.png" alt="第一个全马记录"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E9%A9%AC%E8%B7%91%E6%AD%A5%E7%85%A7.jpg" alt="谢谢各位默默在太阳下暴晒为我们拍照的摄影师们，当然还有一路的志愿者，为我们加油的观众"></p>
<h1 id="第二个马拉松——三亚马"><a href="#第二个马拉松——三亚马" class="headerlink" title="第二个马拉松——三亚马"></a>第二个马拉松——三亚马</h1><p>跑马是会上瘾的，因为你每次跑完都是好了伤疤忘了痛，只记得那些快乐喜悦的瞬间了。<br>跑完宝马之后，开始认识到自己的不足，然而还是没有提高跑量，很随意地日常例跑。报名了无锡，武汉，兰州这些名马都没中，索性报了个不用抽签的三亚马，这样还可以趁机去海南三亚好好玩玩，以跑马的名义去旅行。这次就学乖了，降低了目标，跟着400兔子匀速跑完全马，确定自己的能力。因为这中间几个月也是每月只跑了100多，不可能进步多少。18.03.11这一天，三亚天气很热，我已经过来三亚玩了4天了，三亚真是个好地方，椰树沙滩海洋热带雨林美味海鲜，值得再来玩多几次。8点准时开跑，按照预定计划跟着400男兔子，这个兔子配速很稳，有另外两只兔子前面跑太快了，后面才跟他汇合到一起。旁边很多人跟着他，他们一路说说笑笑，兔子说跟着他破4稳稳的，还一直鼓励旁边的妹子。我就一直默默地跟着他们，内心很腹黑地在记住这些人，看看后面还有几个能留到最后。三月份的三亚还是太热了，但还好我的兔子很稳，最后只有我还一直跟着他跑到了40km，他跟我说可以加点速度自己跑了，去破4吧。于是后面两公里我是自己跑完了，整个过程基本都是530左右匀速跑完，净成绩356。由此我也确定了自己至少是4小时内的水平，满足了✌️</p>
<p>印象深刻的几件事</p>
<ul>
<li>跑前有个大叔也是从外地过来的跑友，他教我将盐丸的小袋子都分别先撕开一个小口，不然比赛的时候手上有汗不好撕开</li>
<li>跑步过程中有个深圳的女跑友认出了我宝马的衣服，我们边跑边聊天，互相鼓励了一段路程<br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E6%B5%B7%E5%8D%97%E9%A9%AC%E8%B7%91%E6%AD%A5%E7%85%A7.jpg" alt="谢谢顶着烈日拍摄的摄影师和志愿者们，三亚马的服务很不错"></li>
</ul>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E6%B5%B7%E5%8D%97%E9%A9%AC%E6%88%90%E7%BB%A9%E8%AF%81%E4%B9%A6.jpg" alt="第一次破4，还是挺自豪的"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E6%B5%B7%E5%8D%97%E9%A9%AC%E8%B7%9F%E7%9D%80400%E5%85%94%E5%AD%90%E8%B7%91.jpg" alt="稳得一匹的兔子，赛后想跟他说声谢谢，可惜找不到人了"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E4%B8%89%E4%BA%9A%E9%A9%AC%E8%B7%91%E5%90%8E%E6%8B%89%E4%BC%B8%E6%9C%8D%E5%8A%A1.jpg" alt="赛后一遍又一遍，耐心帮我拉伸的志愿者，真的很热情，赛后拉伸到位的话，第二天基本就没什么酸痛了"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E6%B5%B7%E5%8D%97%E9%A9%AC%E8%B7%91%E5%AE%8C%E9%80%81%E6%A4%B0%E5%AD%90.jpg" alt="赛后补给值得一提的是去了三亚每天都要喝的椰子汁"></p>
<p>总的来说，这次三亚马，顺利地完成匀速破四的目标，还是比较满意的</p>
<h1 id="特马宝体分队-amp-肯跑团"><a href="#特马宝体分队-amp-肯跑团" class="headerlink" title="特马宝体分队 &amp; 肯跑团"></a>特马宝体分队 &amp; 肯跑团</h1><p>在今年年初我被邓哥拉入了<strong>特马宝体分队</strong>，这也是一个很温暖的跑团，也是在这个跑团里我才认识了发哥，老杜，丽姐这些人，大家经常一起例跑，偶尔聚一下餐。<br>后面约了老苏几次跑步之后，被老苏带进了肯跑团——赤脚军团，老苏是宝体的赤脚大仙，这个跑团也很多人都是跑赤脚的，我后面也被带入坑了。目前来说，群聊天最活跃，跑步技术讨论最热烈的就是这个跑团了，很有意思。<br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%AE%9D%E4%BD%93%E7%89%B9%E9%A9%AC%E4%BE%8B%E8%B7%91.jpg" alt="特马特马，健康跑马"></p>
<h1 id="有氧跑"><a href="#有氧跑" class="headerlink" title="有氧跑"></a>有氧跑</h1><p>三亚马回来之后，我听说跑友<strong>叶文杰</strong>叶兄现在在跑<strong>有氧跑</strong>，进步神速。在4月份初我就开始跟他取经，他跟我都是潮汕人，马上就热情地跟我分享他的训练方法——主要就是按照150心率跑75分钟，每周跑四次，还有要学会管理自己的压力，少吃甜食等。他也给我分享了自己这段时间从一开始150心率540配速到现在500配速的成长经历。我一听就很欢喜这种训练方法，为什么呢？</p>
<ol>
<li>我很<strong>懒</strong>，目前主流的训练方法的要拉长距离，跑间歇，都是要吃苦的，而有氧跑只是在平常跑的基础上多看看心率即可，而且150的心率也只是轻松跑的程度，根本不用去冲速度</li>
<li><strong>怕受伤</strong>。身边很多跑友因为受伤而休跑一段时间，甚至不能跑的比比皆是，我自己也在一开始跑步后就受过一次伤。而受伤的原因一般来说就是因为突然增加的跑量和速度。慢跑70分钟左右受伤的概率相对低很多<br>但这种方法为什么就能进步呢？有没有什么理论依据？于是我开始在网上搜索资料，最后发现原来这个就是鼎鼎大名的 <strong>MAF180</strong> 训练法，MAF180就是用180减去你的年龄，感冒超过2次-5，经常训练+5。以此计算，我也差不多是150。菲利普-马费通，MAF180的创始人，在大书《耐力》里面详细地介绍了这个理论依据，我简单说下我的理解<blockquote>
<p>跑马拉松的时候，我们大部分时间是处于有氧跑的，只有最后冲刺阶段才是无氧，而有氧的主要能量来源是脂肪，所以提高燃脂能力可以在跑马的过程中提供更多的能量。180的公式就是有氧跑的最大值，超过了这个值就开始无氧了(这个值作者是从大量的铁三运动员的数据得出来的）。无氧训练产生的过量乳酸会破坏有氧肌肉酶，balabala说了一大堆。简单来说有氧训练就是让你的身体更会吃脂肪了，而不是吃糖。<br>当然里面也同样说到了减少自己的压力，饮食控制（这个就算了吧）等</p>
</blockquote>
</li>
</ol>
<p>于是怀着试一试的态度，我也开始了我的有氧训练，二四六日开始自己一个人按照心率跑，这时候我才知道为什么宝体那些大神跑步的时候都喜欢低头看表呢好吧，我还是too young too simple。当然中间也有断断续续，但是从那之后也再没拉过长距离和速度了（除了宝体二周年跑了次4分半）<br>期间我也经常跟叶兄分享我的训练结果，他也一直鼓励我按照心率跑，不要因为天气热，大家都在跑速度等原因动摇，我当然说好啊，其实他倒是高看了我，我是懒得去跑速度和长距离的。。</p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/18%E5%B9%B4150%E5%BF%83%E7%8E%87%E8%B7%91%E7%BB%93%E6%9E%9C%E8%AE%B0%E5%BD%95.png" alt="有氧训练对照表，每个月都取同一个天，跑相同时间相同心率是最好的，但是有时候也跟天气，睡眠，压力等有关系"><br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E7%AC%AC%E4%B8%80%E6%AC%A1150%E5%BF%83%E7%8E%87%E8%B7%91.png" alt="4月4号的有氧跑"><br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/8%E6%9C%888%E5%BF%83%E7%8E%87%E8%B7%91.png" alt="8月8号的有氧跑"></p>
<p>可以看到，后面在同样的心率下，我已经由原来的550跑到了差不多510，按照海波的说法，跑马成绩完全可以按照有氧速度减20秒来算，诶，那我已经可以跑330了哈。但到底是不是真的呢？刚好这时候我就中了北马，本来是准备继续好好跑有氧，到12月份再去跑马的。但谁让他是<strong>北京国际马拉松</strong>呢？邓哥说这是我的运气，猪宝连抽三年都没中，贝壳也是准备得很充分结果却没中，所以怎么说也得去跑啊哈哈</p>
<h1 id="北马"><a href="#北马" class="headerlink" title="北马"></a>北马</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>北马前跑了一次从4月份以来第一次半马，5分配，感觉还行，给自己北马的330目标 打打气。感谢发哥陪跑。之后跑马前几天就基本不怎么跑了，马费通博士也强调 训练= 运动+休息，所以要好好休息<br>9.14号周五我跟老苏一起搭上了D904的动卧，同车的还有很多深圳的大神跑友，动不动就是女子首马338，8星级跑者啥的，我默默地坐在旁边听大神们分享经验，连连点头惊叹<br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%8C%97%E9%A9%AC%E7%81%AB%E8%BD%A6%E4%B8%8A%E7%9A%84%E5%90%88%E7%85%A7.jpg" alt="老苏给这张照片取名 《一路向北》"><br>到了北京之后就跟肯跑团的小师妹，老苏，老张一起到农业展览馆领物，羊毛是一根都没捞到。晚上跟夏马老钟他们吃了顿饭，准备好明天参赛的物品。这次我专门买了力为的短裤，很轻薄，还搞了条号码带，用来系号码牌和能量胶。</p>
<h2 id="去吧皮卡丘"><a href="#去吧皮卡丘" class="headerlink" title="去吧皮卡丘"></a>去吧皮卡丘</h2><blockquote>
<p>仰天大笑出门去，我辈岂是蓬蒿人</p>
</blockquote>
<p>15号晚早早就睡了觉，第二天早上，一大早起来穿好战袍，从酒店出发到天安门。安保处主要是检查手环跟号码簿，看到有个妹子在跟几个保安哭诉：“凭什么不让我进去，凭什么”，就因为她手环丢了，看来北马搞了这个手环还是出了一些状况，不知道后面那个妹子能否获得格外开恩呢。经过这个小插曲后，我赶紧去排空之后来到了C区。这里已经是人山人海，我跟着往前挤的两个跑友往前走了一段路，大概在中间的位置。也就是说我前面至少有上万人，这对后面的配速安排有点影响。16号早上这天天气不错（可让我遇到了一次天气凉快点的马了），我心想着放松吧，这次怎么说都能pb了，就算330不了，能pb就行了。不要给自己压力，因为能做的我都做了，接下来就是顺其自然了。开跑前几分钟，接近3w跑友一起<strong>齐唱国歌</strong>，在天安门面前，是挺壮观的。开跑咯，穿过大门的那一刻，按下佳明跑表，go</p>
<p>刚开始起跑的时候感觉心率有点高，五分配一下子150多了。从一开始到跑完，我最大的感受就是人山人海，所以前面我都是从旁边人稍微少一点的地方跑，但是也很难跑得开，基本上一路都是人，而且高手真多，我还想到后面就很多人要掉速了呢。第一次参加这种国际双金赛事，还是太年轻了。如果要在人群中穿梭加速前进的话，那要太浪费体力了，所以我就以510左右的配速跑了前面20几km。到了20多km的时候，人终于散开了点了，于是开始提速，差不多45几配速跑到32km，这时候我算了一下，如果我要跑到330的话，就得以430跑完接下来的10km，看来330没戏。此时我感觉到我的体能还是很充足的，但是大腿内侧感觉有点紧绷，所以我也不敢再加速，要是遇上抽筋啥的，就完蛋了。稳中取胜，最后以337完赛，成功pb了20分钟，也很满足了。</p>
<p>整个过程我一直担心的<strong>撞墙期</strong>也没有出现过，体能也一直很充足。但没有实现目标，一方面的原因是前面人太多了，另一方面，腿部肌肉力量不足也有关系。总的来说，有氧基础的提升确实让我受益匪浅，这也是这次北马想要验证的东西。</p>
<h2 id="美好的回忆"><a href="#美好的回忆" class="headerlink" title="美好的回忆"></a>美好的回忆</h2><ul>
<li>在这次跑步的过程中，遇到了几个轮椅跑者，他们用手不停地转动轮椅前进，有些跑友专门跑在他们前面为他们开路</li>
<li>还遇到了一个视障跑者，他和另一个跑者手上系着绳子，由她来带着他跑。有一个跑友路过他的时候很热情地给他讲周围的盛况：“有好多观众在给你加油呢”，视障跑者也大声地应了：“好嘞”</li>
<li>遇到了几个大爷，年纪很大，却一骑绝尘，果然你大爷还是你大爷</li>
<li>30多k的时候遇到了肯跑团的小师妹，打了下招呼，这也是我这次北马路上遇到的唯一一个深圳跑友了</li>
<li>跑完后晚上跟夏马，嫂子，老钟在天安门前合影，庆祝我们都安全完赛，成功地躲开了山竹<br><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%8C%97%E9%A9%AC%E5%A5%96%E7%89%8C.jpg" alt="也只有北京马拉松才能有霸气的奖牌了"></li>
</ul>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%8C%97%E9%A9%AC%E8%AF%81%E4%B9%A6.jpg" alt="这还得4600名了，北马真是太强了"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%8C%97%E9%A9%AC%E8%B7%91%E6%AD%A5%E5%BF%83%E7%8E%87.png" alt="整体来说心率都不算高，叶兄说我还是太放松了，谁知道呢，说不定加速了就抽筋了，知足常乐"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%8C%97%E9%A9%AC%E7%BB%8F%E8%BF%87%E7%BB%88%E7%82%B9.jpg" alt="冲过终点，咋就不欢呼呢🤦‍♂️，正如夏马所说，整个过程平平淡淡，自然而然就完成了"></p>
<p><img src="/images/%E6%88%8A%E6%88%8D%E5%8C%97%E9%A9%AC%E6%84%9F%E6%82%9F/%E5%8C%97%E9%A9%AC%E8%B7%91%E6%AD%A5%E9%85%B7%E7%85%A7.jpg" alt="同样还是要感谢各位技术高超的摄影师们，还有就是北马的志愿者们，一路为我们加油的北京人民，"></p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul>
<li>有氧基础对于提升跑马的体能还是很必要的，所以有氧跑值得一试！当然有氧基础不一定要靠跑步，也可以通过游泳，自行车等活动</li>
<li>跑者的腿部肌肉专项训练也是必要的，像我这次到后面，明显感觉体力可以，但就是腿有点紧绷，就怕抽筋了，你也不敢乱跑。</li>
<li>北马作为国马级赛事，办的确实是好！这种大型的活动也只有在主办方和当地政府，群众的共同努力下才能实现，感谢🤝</li>
</ul>
<p>最后，当然得用村上春树的话来个高逼格的结尾</p>
<blockquote>
<p>老实说，我甚至觉得每天坚持跑步同意志的强弱，并没有太大的关联，我能够坚持跑步三十年，恐怕还是因为跑步合乎我的性情，至少“不觉得那么痛苦”。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>马拉松</tag>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2 批量修改profiles</title>
    <url>/2018/11/27/zsh-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9profiles/</url>
    <content><![CDATA[<p>iterm2 支持批量修改profiles，只不过这个功能比较难找到，备个案</p>
<p>先修改其中一个profile, 然后如下操作:<br>preferences -&gt; profiles -&gt; 选中已经修改的profile -&gt; (左下角) Other Actions -&gt; Bulk copy from Selected Profile -&gt; 勾选你要复制的配置(例如keys) -&gt; 下方选中要批量修改的profiles -&gt; 点击copy即可</p>
<p><img src="/images/zsh-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9profiles/1-5457843.png" alt="点击bulk copy后的页面"></p>
]]></content>
      <categories>
        <category>软件折腾</category>
      </categories>
      <tags>
        <tag>wiki</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次线上Okhttp超时问题定位</title>
    <url>/2020/11/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOkhttp%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>这几天突然发现线上调三方接口有些超时时间达到了16分钟，我们是通过feign okhttp的方式来调用的，而且设置了feign的okhttp超时时间的。而且我也看到有些请求确实是按照限制的10秒超时的。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">10000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>看日志的过程中发现有一个这个16分钟的超时的错误虽然也是socketTimeout，但是它的timeout是在write的时候发生的。而其他正常的超时是在read的时候发生的。</p>
<p>16分钟超时的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.net.SocketTimeoutException: timeout at okio.SocketAsyncTimeout.newTimeoutException(Okio.kt:159) at okio.AsyncTimeout.exit$jvm(AsyncTimeout.kt:203) at okio.AsyncTimeout$sink$1.write(AsyncTimeout.kt:110)</span><br></pre></td></tr></table></figure>

<p>10秒超时的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.net.SocketTimeoutException: timeout at okio.SocketAsyncTimeout.newTimeoutException(Okio.kt:159) at okio.AsyncTimeout.exit$jvm(AsyncTimeout.kt:203) at okio.AsyncTimeout$source$1.read(AsyncTimeout.kt:163) </span><br></pre></td></tr></table></figure>

<p>然后接下来我了解了下readTimeout和 connectTimeout的概念，也知道了okhttp原来还有writeTimeout的说法。</p>
<p>参考：</p>
<p><a href="https://www.baeldung.com/okhttp-timeouts">A Quick Guide to Timeouts in OkHttp</a></p>
<p><a href="https://www.zhihu.com/question/21609463/answer/160100810">HTTP 在什么情况下会请求超时？ - 严振杰的回答 - 知乎</a></p>
<p>简单说下okhttp的这几个概念</p>
<ul>
<li>connectTimeout：这个比较简单，就是建立连接的超时时间</li>
<li>readTimeout：从建立连接开发，接收服务端的两个数据包之间的最大等待时间。<ul>
<li>例如说下载文件的时候，虽然下载很久但是也没有超时。就是因为服务端一直在给你喂数据，没停过。所以不会触发这个读超时</li>
</ul>
</li>
<li>writeTimeout：写超时是从客户端发送数据给服务端的时候，发送两个数据包之间最大的等待时间。</li>
<li>callTimeout：调用超时，顾名思义，就是整个调用过程的超时时间。包括了上面所有的时间，还有dns域名解析。</li>
</ul>
<p>根据上面的日志可以知道，16m的超时的时候我们还在write，发送请求。这就是为什么readTimeout没有生效的原因。因为都还没到read 服务端响应的时候。</p>
<p>于是我本地测试了下，在上传一个大文件的时候，即使上传的时间已经超过了readTimeout规定的时间，但还是没有触发readTimeout，等到上传完成的时候才触发。</p>
<p>那我是不是给他设置一个writeTimeout就可以了呢？但debug发现，原来okhttpClient默认就设置了writeTimeout为10秒。那为啥线上还是搞到了16m？注意下writeTimeout的定义，发送两个数据包之间最大的等待时间。那只要我一直在发，那就无法触发这个writeTimeout了。</p>
<p>于是我又测试了下，还是上传一个大文件，writeTimeout是默认的10秒。结果上传了3分钟还是没有触发write超时，还是一样write完了直接触发readTimeout。然后我将writeTimeout的时间设置到很小，例如10毫秒，结果就发现很快就触发了writeTimeout。跟线上的错误一样的异常日志。说明两个请求数据包之间间隔的时间超过了10毫秒。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>那问题就比较明朗了，就是线上其实一直都在写，只是对方带宽，网络环境等原因，导致发送请求很慢，但是一直在发。可能几秒发几个字节这样。所以没有触发writeTimeout，更不用说readTimeout。直到最后可能快结束了，出现了一些不可名状的原因，导致触发了writeTimeout。。。最后这个解释有点牵强，我也不清楚为什么最后的超时时间都是16分钟。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>通过设置okhttp的 callTimeout可以完美解决这个问题，简单粗暴。我不管你中间发生了什么，反正我一调用我就开始计时，超时了我就关闭io，然后给你返回个 InterruptIOException。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>鼠标在显示器之间快速移动</title>
    <url>/2023/08/29/%E9%BC%A0%E6%A0%87%E5%9C%A8%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B9%8B%E9%97%B4%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>mac多显示器的情况下，由于习惯用spotlight(alfred) 之类的软件切换应用，导致经常出现的情况下，我跳转（激活）到了另一个显示器上的一个应用，但是鼠标还停留在原显示器上，我想点一下，还得再移动下鼠标过来。多屏幕操作的时候的鼠标移动又挺浪费时间的。</p>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>在网上搜索后发现了一个很好用的方法，参考：<a href="https://apple.stackexchange.com/questions/268697/how-to-quickly-move-mouse-cursor-between-monitors#">How to quickly move mouse cursor between monitors</a> 下面ipatch的回答。</p>
<p>方法如下</p>
<ol>
<li>下载 <a href="http://www.hammerspoon.org/">hammerspoon</a></li>
<li>下载它的插件 spoon <a href="https://www.hammerspoon.org/Spoons/MouseFollowsFocus.html">MouseFollowsFocus</a>（如果觉得不适应的可以下载我的脚本，做了一些优化<a href="https://github.com/lizhecao/databases/blob/main/mac/hammerspoon/MouseFollowsFocus.spoon/init.lua">MyMouseFollowsFocus</a> ）</li>
<li>vim ~/.hammerspoon/init.lua</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mouse_follows_focus = hs.loadSpoon(<span class="string">&quot;MouseFollowsFocus&quot;</span>)</span><br><span class="line">mouse_follows_focus:configure(&#123;&#125;)</span><br><span class="line">mouse_follows_focus:start()</span><br></pre></td></tr></table></figure>



<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote>
<p>默认的脚本存在一些对我使用体验较差的问题，所以我做了一些优化</p>
</blockquote>
<p>不想看原理的可以直接下载我的脚本即可：<a href="https://github.com/lizhecao/databases/blob/main/mac/hammerspoon/MouseFollowsFocus.spoon/init.lua">MyMouseFollowsFocus</a><br>如果需要定制化，可以在修改脚本后，重新加载就可以了。脚本默认加载后的位置在~/.hammerspoon/Spoons/MouseFollowsFocus.spoon/init.lua</p>
<ol>
<li>xnip截图软件会自动激活所有桌面，导致鼠标重复跳转。</li>
</ol>
<p>解决方法：直接禁用掉xnip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if hs.application.frontmostApplication():name() ~= &quot;Xnip Helper&quot; then</span><br><span class="line">  self:updateMouse(window)</span><br><span class="line">else</span><br><span class="line">  print(&quot;xnip app running&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>同个显示器下鼠标也自动跳转了。这个很困扰我，因为同个显示器下移动有点错愕感，而且也没什么必要。因为距离很小了</p>
<p>解决方法：不同显示器下才跳转。判断的位置由应用变成显示器。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件折腾</category>
      </categories>
      <tags>
        <tag>hammerspoon</tag>
      </tags>
  </entry>
  <entry>
    <title>软件电脑问题咨询解决服务</title>
    <url>/2022/09/16/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>本人是一名软件开发工程师，目前就职于某大厂， 日常开发中遇到的软件问题也很多，所以积累了很多经验，希望能够帮到有需要的朋友。</p>
<p>服务内容包括但不限于以下几种：</p>
<ol>
<li>软件开发，数据处理工具（例如批量处理excel、文档）</li>
<li>软件安装、激活</li>
<li>其他各种软件问题（软件报错、无法运行之类）</li>
</ol>
<p><img src="/images/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/image-20220916113948499.png" alt="image-20220916113948499"></p>
<p><img src="/images/%E8%BD%AF%E4%BB%B6%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98%E5%92%A8%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1/image-20220916114326451.png" alt="image-20220916114326451"></p>
<p>有需要的可以通过以下几种方式联系我</p>
<ol>
<li><p>发邮件：<a href="mailto:&#x35;&#52;&#49;&#x39;&#57;&#53;&#49;&#52;&#x39;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;">&#x35;&#52;&#49;&#x39;&#57;&#53;&#49;&#52;&#x39;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;</a></p>
</li>
<li><p>微信号：zhecaoli</p>
</li>
<li><p>直接在下面评论留言：给下你的邮箱或者微信号</p>
</li>
</ol>
<p>根据问题解决所需的时间，会适当收一点费用。介意勿联。</p>
]]></content>
      <categories>
        <category>软件折腾</category>
      </categories>
  </entry>
</search>
